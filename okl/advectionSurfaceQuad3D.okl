#define p_LIFT (0.5f*(p_Nq-1)*p_Nq)

void upwindFluxS(const dfloat nx, const dfloat ny, const dfloat nz,
		 const dfloat u, const dfloat v, const dfloat w,
		 const dfloat * restrict qp, const dfloat * restrict qm,
		 dfloat * restrict fluxq){

    const dfloat udotn = u*nx+v*ny+w*nz;

    // TW: need to double check the sign in front of occaFabs (might need to switch to - occaFabs(udotn)
    fluxq[0] = 0.5f*(udotn*(qp[1]-qm[1]) + 0.f*occaFabs(udotn)*(qp[0] - qm[0]));
    fluxq[1] = 0.5f*(udotn*(qp[0]-qm[0]) + 0.f*occaFabs(udotn)*(qp[1] - qm[1]));

    for(int n=2;n<p_Nfields;++n)
	fluxq[n] = 0;

}

void upwindFluxW(const dfloat nx, const dfloat ny, const dfloat nz,
		 const dfloat u, const dfloat v, const dfloat w,
		 const dfloat * restrict qp, const dfloat * restrict qm,
		 dfloat * restrict fluxq){

    const dfloat udotn = u*nx+v*ny+w*nz;

    // TW: need to double check the sign in front of occaFabs (might need to switch to - occaFabs(udotn)
    fluxq[0] = 0.5f*(udotn*(qp[1]+qm[1]) + 0.f*occaFabs(udotn)*(qp[0] - qm[0]));
    fluxq[1] = 0.5f*(udotn*(qp[0]+qm[0]) + 0.f*occaFabs(udotn)*(qp[1] - qm[1]));

    for(int n=2;n<p_Nfields;++n)
	fluxq[n] = 0;

}

void upwindFlux(const dfloat nx, const dfloat ny, const dfloat nz,
		const dfloat u, const dfloat v, const dfloat w,
		const dfloat * restrict dq,
		dfloat * restrict fluxq){

    const dfloat udotn = u*nx+v*ny+w*nz;

    // TW: need to double check the sign in front of occaFabs (might need to switch to - occaFabs(udotn)
    fluxq[0] = 0.5f*(udotn*dq[1] + 0.f*occaFabs(udotn)*dq[0]);
    fluxq[1] = 0.5f*(udotn*dq[0] + 0.f*occaFabs(udotn)*dq[1]);

    for(int n=2;n<p_Nfields;++n)
	fluxq[n] = 0;

}

// pointwise SEM-DG lift
kernel void advectionSurfaceLSERKQuad3D(const iint Nelements,
					const dfloat * restrict sgeo,
					const dfloat * restrict LIFTT,
					const iint   * restrict vmapM,
					const iint   * restrict vmapP,
					const dfloat time,
					const dfloat * restrict x,
					const dfloat * restrict y,
					const dfloat * restrict z,
					const dfloat * restrict q,
					dfloat * restrict rhsq){
    // for all elements
    for(iint eo=0;eo<Nelements;eo+=p_NblockS;outer0){
    
	// for all faces (global barrier at end of body of this loop)
	for(iint face=0;face<p_Nfaces;++face){      

	    for(iint es=0;es<p_NblockS;++es;inner1){
		for(iint i=0;i<p_Nq;++i;inner0){ 

		    const iint eM = eo + es;
	  
		    if(eM<Nelements){	      
			// load surface geofactors for this face
			const iint sid = eM*p_Nsgeo*p_Nq*p_Nfaces + face*p_Nsgeo*p_Nq + i; 
			const dfloat nx = sgeo[sid+0*p_Nq];
			const dfloat ny = sgeo[sid+1*p_Nq];
			const dfloat nz = sgeo[sid+2*p_Nq];
			const dfloat sJ = sgeo[sid+3*p_Nq];
			const dfloat invJ = sgeo[sid+4*p_Nq];

			// indices of negative and positive traces of face node
			const iint id  = eM*p_Nq*p_Nfaces + face*p_Nq + i;
			const int idM = vmapM[id];
			const int idP = vmapP[id];
			const int eP = idP/p_Np;

			const dfloat xn = x[idM];
			const dfloat yn = y[idM];
			const dfloat zn = z[idM];

			const dfloat un = yn;
			const dfloat vn = -xn;
			const dfloat wn = 0;

			const iint vidM = eM*p_Np*p_Nfields + (idM%p_Np);
			const iint vidP = eP*p_Np*p_Nfields + (idP%p_Np);

			dfloat dq[p_Nfields], fluxq[p_Nfields];
	    
			occaUnroll(p_Nfields)
			    for(int fld=0;fld<p_Nfields;++fld){
				const dfloat qM = q[vidM+fld*p_Np];
				dfloat qP = q[vidP+fld*p_Np]; // assumes chunks of p_Np*p_Nfields per element
				dq[fld] = qP-qM;
			    }

			upwindFlux(nx, ny, nz, un, vn, wn, dq, fluxq);
	    
			const dfloat sc = invJ*sJ*p_LIFT;
	    
			occaUnroll(p_Nfields)
			    for(int fld=0;fld<p_Nfields;++fld){
				rhsq[vidM+fld*p_Np] += sc*fluxq[fld]; // TW dq[fld];
			    }
		    }
		}
	    }
	    // wait for all global memory writes of the previous inner loop to complete
	    barrier(globalMemFence);
	}
    }
}

kernel void advectionSurfaceLSERKmixedQuad3D(const iint Nelements,
						const dfloat * restrict sgeo,
						const dfloat * restrict vgeo,
						const dfloat * restrict LIFTT,
						const iint   * restrict vmapM,
						const iint   * restrict vmapP,
						const dfloat time,
						const dfloat * restrict x,
						const dfloat * restrict y,
						const dfloat * restrict z,
						const dfloat * restrict q,
						const dfloat * restrict qw,
						dfloat * restrict rhsqs,
						dfloat * restrict rhsqw){
    // for all elements
    for(iint eo=0;eo<Nelements;eo+=p_NblockS;outer0){
    
	// for all faces (global barrier at end of body of this loop)
	for(iint face=0;face<p_Nfaces;++face){      

      
	    for(iint es=0;es<p_NblockS;++es;inner1){
		for(iint i=0;i<p_Nq;++i;inner0){ 

		    const iint eM = eo + es;
	  
		    if(eM<Nelements){
	    
			// load surface geofactors for this face
			const iint sid = eM*p_Nsgeo*p_Nq*p_Nfaces + face*p_Nsgeo*p_Nq + i; 
			const dfloat nx = sgeo[sid+0*p_Nq];
			const dfloat ny = sgeo[sid+1*p_Nq];
			const dfloat nz = sgeo[sid+2*p_Nq];
			const dfloat sJ = sgeo[sid+3*p_Nq];
			const dfloat invJ = sgeo[sid+4*p_Nq];

			// indices of negative and positive traces of face node
			const iint id  = eM*p_Nq*p_Nfaces + face*p_Nq + i;
			const int idM = vmapM[id];
			const int idP = vmapP[id];
			const int eP = idP/p_Np;

			const dfloat xn = x[idM];
			const dfloat yn = y[idM];
			const dfloat zn = z[idM];

			const dfloat un = yn;
			const dfloat vn = -xn;
			const dfloat wn = 0;

			const iint vidM = eM*p_Np*p_Nfields + (idM%p_Np);
			const iint vidP = eP*p_Np*p_Nfields + (idP%p_Np);

			dfloat qps[p_Nfields], qms[p_Nfields], qpw[p_Nfields], qmw[p_Nfields], fluxqs[p_Nfields], fluxqw[p_Nfields];
	    
			occaUnroll(p_Nfields)
			    for(int fld=0;fld<p_Nfields;++fld){
				const dfloat qMs = q[vidM+fld*p_Np];
				dfloat qPs = q[vidP+fld*p_Np]; // assumes chunks of p_Np*p_Nfields per element
				const dfloat qMw = qw[vidM+fld*p_Np];
				dfloat qPw = qw[vidP+fld*p_Np]; // assumes chunks of p_Np*p_Nfields per element
				qps[fld] = qPs;
				qms[fld] = qMs;
				qpw[fld] = qPw;
				qmw[fld] = qMw;
			    }

			upwindFluxS(nx, ny, nz, un, vn, wn, qps,qms, fluxqs);
			upwindFluxW(nx, ny, nz, un, vn, wn, qpw,qmw, fluxqw);

			const int gbase = eM*p_Np*p_Nvgeo + (idM%p_Np);
			const dfloat w = vgeo[gbase + p_Np*10]/vgeo[gbase+p_Np*9];
			const dfloat j = vgeo[gbase + p_Np*9];
	    
			const dfloat sc = invJ*sJ*p_LIFT;

			occaUnroll(p_Nfields)
			    for(int fld=0;fld<p_Nfields;++fld){
				rhsqs[vidM+fld*p_Np] += sc*fluxqs[fld]; // TW dq[fld];
				rhsqw[vidM+fld*p_Np] += sc*fluxqw[fld]; // TW dq[fld];
			    }
		    }
		}
	    }

	    // wait for all global memory writes of the previous inner loop to complete
	    barrier(globalMemFence);     
	}
    }
}

// pointwise SEM-DG lift
kernel void advectionSurfaceLSERKexpMixedQuad3D(const iint Nelements,
						const dfloat * restrict sgeo,
						const dfloat * restrict vgeo,
						const dfloat * restrict LIFTT,
						const iint   * restrict vmapM,
						const iint   * restrict vmapP,
						const dfloat time,
						const dfloat * restrict x,
						const dfloat * restrict y,
						const dfloat * restrict z,
						const dfloat * restrict q,
						const dfloat * restrict qw,
						dfloat * restrict rhsqs,
						dfloat * restrict rhsqw){
  
  
  
    // for all elements
    for(iint eo=0;eo<Nelements;eo+=p_NblockS;outer0){
    
	// for all faces (global barrier at end of body of this loop)
	for(iint face=0;face<p_Nfaces;++face){      

      
	    for(iint es=0;es<p_NblockS;++es;inner1){
		for(iint i=0;i<p_Nq;++i;inner0){ 

		    const iint eM = eo + es;
	  
		    if(eM<Nelements){
	    
			// load surface geofactors for this face
			const iint sid = eM*p_Nsgeo*p_Nq*p_Nfaces + face*p_Nsgeo*p_Nq + i; 
			const dfloat nx = sgeo[sid+0*p_Nq];
			const dfloat ny = sgeo[sid+1*p_Nq];
			const dfloat nz = sgeo[sid+2*p_Nq];
			const dfloat sJ = sgeo[sid+3*p_Nq];
			const dfloat invJ = sgeo[sid+4*p_Nq];

			// indices of negative and positive traces of face node
			const iint id  = eM*p_Nq*p_Nfaces + face*p_Nq + i;
			const int idM = vmapM[id];
			const int idP = vmapP[id];
			const int eP = idP/p_Np;

			const dfloat xn = x[idM];
			const dfloat yn = y[idM];
			const dfloat zn = z[idM];

			const dfloat un = yn;
			const dfloat vn = -xn;
			const dfloat wn = 0;

			const iint vidM = eM*p_Np*p_Nfields + (idM%p_Np);
			const iint vidP = eP*p_Np*p_Nfields + (idP%p_Np);

			dfloat qps[p_Nfields], qms[p_Nfields], qpw[p_Nfields], qmw[p_Nfields], fluxqs[p_Nfields], fluxqw[p_Nfields];
	    
			occaUnroll(p_Nfields)
			    for(int fld=0;fld<p_Nfields;++fld){
				const dfloat qMs = q[vidM+fld*p_Np];
				dfloat qPs = q[vidP+fld*p_Np]; // assumes chunks of p_Np*p_Nfields per element
				const dfloat qMw = qw[vidM+fld*p_Np];
				dfloat qPw = qw[vidP+fld*p_Np]; // assumes chunks of p_Np*p_Nfields per element
				qps[fld] = qPs;
				qms[fld] = qMs;
				qpw[fld] = qPw;
				qmw[fld] = qMw;
			    }

			upwindFluxS(nx, ny, nz, un, vn, wn, qps,qms, fluxqs);
			upwindFluxW(nx, ny, nz, un, vn, wn, qpw,qmw, fluxqw);

			const int gbase = eM*p_Np*p_Nvgeo + (idM%p_Np);
			const dfloat w = vgeo[gbase + p_Np*10]/*/vgeo[gbase+p_Np*9]*/;
	    
			const dfloat sc = invJ*sJ*p_LIFT;

			occaUnroll(p_Nfields)
			    for(int fld=0;fld<p_Nfields;++fld){
				rhsqs[vidM+fld*p_Np] += w*sc*fluxqs[fld]; // TW dq[fld];
				rhsqw[vidM+fld*p_Np] += w*sc*fluxqw[fld]; // TW dq[fld];
			    }
		    }
		}
	    }

	    // wait for all global memory writes of the previous inner loop to complete
	    barrier(globalMemFence);     
	}
    }
}

// pointwise SEM-DG lift
kernel void advectionSurfaceMRSAABQuad3D(const iint Nelements,
					 const iint * restrict elementIds,
					 const iint shift,
					 const dfloat * restrict sgeo,
					 const dfloat * restrict LIFTT,
					 const iint   * restrict vmapM,
					 const iint   * restrict vmapP,
					 const iint time,
					 const dfloat * restrict x,
					 const dfloat * restrict y,
					 const dfloat * restrict z,
					 const dfloat * restrict fQM,
					 dfloat * restrict rhsq){
  
  
  
    // for all elements
    for(iint eo=0;eo<Nelements;eo+=p_NblockS;outer0){
    
	// for all faces (global barrier at end of body of this loop)
	for(iint face=0;face<p_Nfaces;++face){      

      
	    for(iint es=0;es<p_NblockS;++es;inner1){
		for(iint i=0;i<p_Nq;++i;inner0){ 
		    //transition from fake to real element numbering
		    const iint e = eo + es;
	  
		    if(e<Nelements){
			const iint eM = elementIds[e];

			// load surface geofactors for this face
			const iint sid = eM*p_Nsgeo*p_Nq*p_Nfaces + face*p_Nsgeo*p_Nq + i; 
			const dfloat nx = sgeo[sid+0*p_Nq];
			const dfloat ny = sgeo[sid+1*p_Nq];
			const dfloat nz = sgeo[sid+2*p_Nq];
			const dfloat sJ = sgeo[sid+3*p_Nq];
			const dfloat invJ = sgeo[sid+4*p_Nq];

			// indices of negative and positive traces of face node
			const iint id  = eM*p_Nq*p_Nfaces + face*p_Nq + i;
			const int idM = vmapM[id];
			const int idP = vmapP[id];
			const int eP = idP/p_Np;
			const int vM = idM%p_Np;
			const iint vP = idP%p_Np;

			const dfloat xn = x[idM];
			const dfloat yn = y[idM];
			const dfloat zn = z[idM];

			const dfloat un = yn;
			const dfloat vn = -xn;
			const dfloat wn = 0;

			const iint vidM = eM*p_Np*p_Nfields + vM;
			const iint vidP = eP*p_Np*p_Nfields + vP;

			dfloat qp[p_Nfields], qm[p_Nfields], fluxq[p_Nfields];
	    
			occaUnroll(p_Nfields)
			    for(int fld=0;fld<p_Nfields;++fld){
				const dfloat qM = fQM[vidM+fld*p_Np];
				dfloat qP = fQM[vidP+fld*p_Np]; // assumes chunks of p_Np*p_Nfields per element

				qp[fld] = qP;
				qm[fld] = qM;
			    }

			// upwind flux
			upwindFluxS(nx, ny, nz, un, vn, wn, qp,qm, fluxq);
	    
			// evaluate "flux" terms: (sJ/J)*(D+sigma*D*D)*(q^* - q^-)
			const dfloat sc = invJ*sJ*p_LIFT;

			//account for new layout of rhsq
			const iint vidNew = eM*p_nrhs*p_Np*p_Nfields + shift*p_Np*p_Nfields + vM;
	    
			occaUnroll(p_Nfields)
			    for(int fld=0;fld<p_Nfields;++fld){
				rhsq[vidNew+fld*p_Np] += sc*fluxq[fld]; // TW dq[fld];
			    }
		    }
		}
	    }

	    // wait for all global memory writes of the previous inner loop to complete
	    barrier(globalMemFence);

      
	}
    }
}
