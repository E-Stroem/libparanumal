void flux(const dfloat nx, const dfloat ny, const dfloat nz,
	  const dfloat alpha, const dfloat beta,
	  const dfloat * restrict dq,
	  dfloat * restrict fluxq){

  fluxq[0] = alpha*dq[0] - beta*p_sqrtRT*(nx*dq[1] + ny*dq[2] + nz*dq[3]);

  fluxq[1] = alpha*dq[1] - beta*p_sqrtRT*(nx*dq[0] + nx*p_sqrt2*dq[4] + ny*dq[7] + nz*dq[8]);
  fluxq[2] = alpha*dq[2] - beta*p_sqrtRT*(ny*dq[0] + ny*p_sqrt2*dq[5] + nx*dq[7] + nz*dq[9]);
  fluxq[3] = alpha*dq[3] - beta*p_sqrtRT*(nz*dq[0] + nz*p_sqrt2*dq[6] + nx*dq[8] + ny*dq[9]);

  fluxq[4] = alpha*dq[4] - beta*p_sqrtRT*(p_sqrt2*nx*dq[1]);
  fluxq[5] = alpha*dq[5] - beta*p_sqrtRT*(p_sqrt2*ny*dq[2]);
  fluxq[6] = alpha*dq[6] - beta*p_sqrtRT*(p_sqrt2*nz*dq[3]);

  fluxq[7] = alpha*dq[7] - beta*p_sqrtRT*(nx*dq[2]+ny*dq[1]);
  fluxq[8] = alpha*dq[8] - beta*p_sqrtRT*(nx*dq[3]+nz*dq[1]);
  fluxq[9] = alpha*dq[9] - beta*p_sqrtRT*(ny*dq[3]+nz*dq[2]);
}

/*void boundaryCondition(dfloat *qP, const dfloat qM,const dfloat nx, const dfloat ny, const dfloat nz,const dfloat q2, const dfloat q3, const dfloat q4, int fld) {
     if (fld == 1)
     	*qP = qM-(q2*nx + q3*ny + q4*nz)*nx;
     else if (fld == 2)
        *qP = qM-(q2*nx + q3*ny + q4*nz)*ny;
     else if (fld == 3)
        *qP = qM-(q2*nx + q3*ny + q4*nz)*nz;
     else
     	 *qP = qM;
}*/

void boundaryCondition(dfloat *qP,const dfloat qM, int fld) {
     if ((fld >= 1) && (fld <= 3)) *qP = -qM;
     else *qP = qM;
}

// pointwise SEM-DG lift
kernel void boltzmannSurfaceQuad3D(const iint Nelements,
				   const dfloat * restrict sgeo,
				   const dfloat * restrict LIFTT,
				   const iint   * restrict vmapM,
				   const iint   * restrict vmapP,
				   const dfloat time,
				   const dfloat * restrict x,
				   const dfloat * restrict y,
				   const dfloat * restrict z,
				   const dfloat * restrict q,
				   dfloat * restrict rhsq){
  
  
#define p_LIFT (0.5f*(p_Nq-1)*p_Nq)
  
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS;outer0){
    
    // for all faces (global barrier at end of body of this loop)
    for(iint face=0;face<p_Nfaces;++face){      

      
      for(iint es=0;es<p_NblockS;++es;inner1){
	for(iint i=0;i<p_Nq;++i;inner0){ 

	  const iint eM = eo + es;
	  
	  if(eM<Nelements){
	    
	    // load surface geofactors for this face
	    const iint sid = eM*p_Nsgeo*p_Nq*p_Nfaces + face*p_Nsgeo*p_Nq + i; 
	    const dfloat nx = sgeo[sid+0*p_Nq];
	    const dfloat ny = sgeo[sid+1*p_Nq];
	    const dfloat nz = sgeo[sid+2*p_Nq];
	    const dfloat sJ = sgeo[sid+3*p_Nq];
	    const dfloat invJ = sgeo[sid+4*p_Nq];

	    // indices of negative and positive traces of face node
	    const iint id  = eM*p_Nq*p_Nfaces + face*p_Nq + i;
	    const int idM = vmapM[id];
	    const int idP = vmapP[id];
	    const int eP = idP/p_Np;

	    const iint vidM = eM*p_Np*p_Nfields + (idM%p_Np);
	    const iint vidP = eP*p_Np*p_Nfields + (idP%p_Np);

	    dfloat dq[p_Nfields], fluxq[p_Nfields];
	    
	    occaUnroll(p_Nfields)
	      for(int fld=0;fld<p_Nfields;++fld){
		const dfloat qM = q[vidM+fld*p_Np];
		dfloat qP = q[vidP+fld*p_Np]; // assumes chunks of p_Np*p_Nfields per element
		//if(eP == eM) boundaryCondition(&qP,qM,nx,ny,nz,q[vidM+p_Np],q[vidM+2*p_Np],q[vidM+3*p_Np], fld);
		if (eP == eM) boundaryCondition(&qP,qM,fld);
		dq[fld] = qP-qM;
	      }


	    // D = nx*A + ny*B + nz*C
   	    // compute 0.5*[q] + 0.5*D*[q]/sqrt(RT)
	    const dfloat alpha = 0.5, beta = 0.5*p_invsqrtRT;

	    flux(nx, ny, nz, alpha, beta, dq, fluxq);

	    const dfloat one = 1.0, zero = 0.0;

	    // compute D*(0.5*[q] + 0.5*D*[q])
	    flux(nx, ny, nz, zero, one, fluxq, dq);
	    
	    // evaluate "flux" terms: (sJ/J)*(D+sigma*D*D)*(q^* - q^-)
	    const dfloat sc = invJ*sJ*p_LIFT;

	    occaUnroll(p_Nfields)
	      for(int fld=0;fld<p_Nfields;++fld){
		rhsq[vidM+fld*p_Np] += sc*dq[fld]; // TW dq[fld];
	      }
	  }
	}
      }

      // wait for all global memory writes of the previous inner loop to complete
      barrier(globalMemFence);

      
    }
  }
}

// pointwise SEM-DG lift
kernel void boltzmannSurfaceMRQuad3D(const iint Nelements,
				     const iint * restrict elementIds,
				     const iint shift,
				     const dfloat * restrict sgeo,
				     const dfloat * restrict LIFTT,
				     const iint   * restrict vmapM,
				     const iint   * restrict mapP,
				     const iint time,
				     const dfloat * restrict x,
				     const dfloat * restrict y,
				     const dfloat * restrict z,
				     const dfloat * restrict q,
				     	   dfloat * restrict fQM,
				           dfloat * restrict rhsq){
  
  
#define p_LIFT (0.5f*(p_Nq-1)*p_Nq)
  
  // for all elements
  for(iint eo=0;eo<Nelements;eo+=p_NblockS;outer0){
    
    // for all faces (global barrier at end of body of this loop)
    for(iint face=0;face<p_Nfaces;++face){      

      
      for(iint es=0;es<p_NblockS;++es;inner1){
	for(iint i=0;i<p_Nq;++i;inner0){ 
	  //transition from fake to real element numbering
	  const iint e = eo + es;
	  
	  if(e<Nelements){
	    const iint eM = elementIds[e];

	    // load surface geofactors for this face
	    const iint sid = eM*p_Nsgeo*p_Nq*p_Nfaces + face*p_Nsgeo*p_Nq + i; 
	    const dfloat nx = sgeo[sid+0*p_Nq];
	    const dfloat ny = sgeo[sid+1*p_Nq];
	    const dfloat nz = sgeo[sid+2*p_Nq];
	    const dfloat sJ = sgeo[sid+3*p_Nq];
	    const dfloat invJ = sgeo[sid+4*p_Nq];

	    // indices of negative and positive traces of face node
	    const iint id  = eM*p_Nq*p_Nfaces + face*p_Nq + i;
	    const iint idP = mapP[id];
	    const iint eP = idP/(p_Nfaces*p_Nq);
	    const iint vM = vmapM[id]%p_Np;
	    const iint vP = idP - eP*p_Nfaces*p_Nq;

	    const iint vidM = eM*p_Nq*p_Nfaces*p_Nfields + face*p_Nq + i;
	    const iint vidP = eP*p_Nq*p_Nfaces*p_Nfields + vP;

	    dfloat dq[p_Nfields], fluxq[p_Nfields];
	    
	    occaUnroll(p_Nfields)
	      for(int fld=0;fld<p_Nfields;++fld){
		const dfloat qM = fQM[vidM+fld*p_Nfp*p_Nfaces];
		dfloat qP = fQM[vidP+fld*p_Nfp*p_Nfaces]; 
		//if(eP == eM) boundaryCondition(&qP,qM,nx,ny,nz,q[vidM+p_Np],q[vidM+2*p_Np],q[vidM+3*p_Np], fld);
		if (eP == eM) boundaryCondition(&qP,qM,fld);
		dq[fld] = qP-qM;
	      }


	    // D = nx*A + ny*B + nz*C
   	    // compute 0.5*[q] + 0.5*D*[q]/sqrt(RT)
	    const dfloat alpha = 0.5, beta = 0.5*p_invsqrtRT;

	    flux(nx, ny, nz, alpha, beta, dq, fluxq);

	    const dfloat one = 1.0, zero = 0.0;

	    // compute D*(0.5*[q] + 0.5*D*[q])
	    flux(nx, ny, nz, zero, one, fluxq, dq);
	    
	    // evaluate "flux" terms: (sJ/J)*(D+sigma*D*D)*(q^* - q^-)
	    const dfloat sc = invJ*sJ*p_LIFT;

	    //account for new layout of rhsq
	    const iint vidNew = eM*p_nrhs*p_Np*p_Nfields + shift*p_Np*p_Nfields + vM;
	    
	    occaUnroll(p_Nfields)
	      for(int fld=0;fld<p_Nfields;++fld){
		rhsq[vidNew+fld*p_Np] += sc*dq[fld]; // TW dq[fld];
	      }
	  }
	}
      }

      // wait for all global memory writes of the previous inner loop to complete
      barrier(globalMemFence);

      
    }
  }
}

