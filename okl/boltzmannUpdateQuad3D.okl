kernel void boltzmannLSERKUpdateQuad3D(const iint Nelements,
				       const iint * restrict elementIDs,
				       const iint saved,
				       const dfloat dt,
				       const dfloat rka,
				       const dfloat rkb,
				       const iint shift,
				       const dfloat * restrict rhsq,
				       dfloat * restrict qpop,
				       const dfloat * restrict qCorr,
				       dfloat * restrict resq,
				       dfloat * restrict qpre){
  
  // Low storage Runge Kutta time step update
  for(iint es=0;es<Nelements;++es;outer0){

    shared iint e;
    
    for(iint n=0;n<p_Np;++n;inner0){

      e = elementIDs[es];
      
      for(iint fld=0; fld<p_Nfields; ++fld){

	const iint id = e*p_Np*p_Nfields + fld*p_Np + n;
	
	dfloat r_resq = resq[id];
	dfloat r_rhsq = rhsq[id]; 
	dfloat r_q = qpre[id];
	
	r_resq = rka*r_resq + dt*(r_rhsq + qCorr[id]);
	r_q   += rkb*r_resq;
	if (saved)
	  qpop[es*p_Np*p_Nfields*p_nrhs + shift*p_Np*p_Nfields + fld*p_Np + n] = r_rhsq;
	
	resq[id] = r_resq;

	qpre[id] = r_q;
      }
    }
  }
}


kernel void boltzmannLSERKTraceUpdateQuad3D(const iint Nelements,
					    const iint * restrict elementIDs,
					    const iint * restrict vmapM,
					    dfloat * restrict fQM,
					    dfloat * restrict qpre,
					    dfloat * restrict q){

  for (iint es = 0; es < Nelements; ++es; outer0) {
    for(iint n=0;n<p_Np;++n;inner0){
      const iint e = elementIDs[es];

      for (iint fld = 0; fld < p_Nfields; ++fld) {
	const iint id = e*p_Np*p_Nfields + fld*p_Np + n;
	q[id] = qpre[id];
	if (n < p_Nfaces*p_Nfp) {
	  const iint iid  = e*p_Nfp*p_Nfaces + n;
	  const iint qidM = vmapM[iid] - e*p_Np;
	  const iint qid  = e*p_Nfp*p_Nfaces*p_Nfields + n;
	  fQM[qid+fld*p_Nfp*p_Nfaces] = qpre[qidM+fld*p_Np+e*p_Np*p_Nfields];
	}
      }
    }
  }
}

					    

kernel void boltzmannMRSAABUpdateQuad3D(const iint Nelements,
					const iint * restrict elementIds,
					const dfloat expdt,
					const dfloat ab1,
					const dfloat ab2,
					const dfloat ab3,
					const dfloat saab1,
					const dfloat saab2,
					const dfloat saab3,
					const iint   shift,
					const dfloat * restrict rhsq,
					const iint   * restrict vmapM,
					dfloat * restrict fQM,
					dfloat * restrict qCorr,
					dfloat * restrict q){

  // Low storage Runge Kutta time step update
  for(iint es=0;es<Nelements;++es;outer0){
    
    shared dfloat s_q[p_Np*p_Nfields];
    shared iint e;
    for(iint n=0;n<p_StoVmaxNodes;++n;inner0){
      e  = elementIds[es];
      if(n<p_Np){
	const iint id = n + e*p_Np*p_Nfields;
	const iint rid = n + e*p_Np*p_Nfields*3;

        // hard-coded for 3th order
	const iint rhsId1 = rid + ((shift+0)%3)*p_Nfields*p_Np;
	const iint rhsId2 = rid + ((shift+1)%3)*p_Nfields*p_Np;
	const iint rhsId3 = rid + ((shift+2)%3)*p_Nfields*p_Np;

	for(iint fld=0; fld< p_Nfields; ++fld){
	  
	  //load q and update
	  if(fld<4)
	    s_q[n+fld*p_Np] = q[id+fld*p_Np] + ab1*rhsq[rhsId1+fld*p_Np]+ab2*rhsq[rhsId2+fld*p_Np]+ab3*rhsq[rhsId3+fld*p_Np];
	  else
	    s_q[n+fld*p_Np] = expdt*q[id+fld*p_Np] + saab1*(rhsq[rhsId1+fld*p_Np] + qCorr[rhsId1+fld*p_Np]) + saab2*(rhsq[rhsId2+fld*p_Np] + qCorr[rhsId2+fld*p_Np]) + saab3*(rhsq[rhsId3+fld*p_Np] + qCorr[rhsId3+fld*p_Np]);
	}
      }
    }
    // make sure all node data is loaded into shared
    barrier(localMemFence);
    for(iint n=0;n<p_StoVmaxNodes;++n;inner0){
      // Update q
      if(n<p_Np){

        const iint id = p_Nfields*e*p_Np + n;

        for (iint fld = 0; fld < p_Nfields; ++fld){
	  q[id+fld*p_Np]   = s_q[n+fld*p_Np];
	}

      }
      if(n<p_Nfaces*p_Nfp){

        const iint iid  = e*p_Nfp*p_Nfaces + n;
	const iint qidM = vmapM[iid] - e*p_Np;
	const iint qid  = e*p_Nfp*p_Nfaces*p_Nfields + n;

	for (iint fld = 0; fld < p_Nfields; ++fld){
	  fQM[qid+fld*p_Nfp*p_Nfaces] = s_q[qidM+fld*p_Np];
	}
      }

    }

  }
}
  

kernel void boltzmannMRSAABTraceUpdateQuad3D(const iint Nelements,
					     const iint * restrict elementIds,
					     const dfloat expdt,
					     const dfloat ab1,
					     const dfloat ab2,
					     const dfloat ab3,
					     const dfloat saab1,
					     const dfloat saab2,
					     const dfloat saab3,
					     const iint   shift,
					     const dfloat * restrict rhsq,
					     const iint   * restrict vmapM,
					     dfloat * restrict fQM,
					     dfloat * restrict qCorr,
					     dfloat * restrict q){
  
  // Low storage Runge Kutta time step update
  for(iint es=0;es<Nelements;++es;outer0){
    
    shared dfloat s_q[p_Np*p_Nfields];
    shared iint e;
    for(iint n=0;n<p_StoVmaxNodes;++n;inner0){
      e  = elementIds[es];
      if(n<p_Np){
	const iint id = n + e*p_Np*p_Nfields;
	const iint rid = n + e*p_Np*p_Nfields*3;

        // hard-coded for 3th order
	const iint rhsId1 = rid + ((shift+0)%3)*p_Nfields*p_Np;
	const iint rhsId2 = rid + ((shift+1)%3)*p_Nfields*p_Np;
	const iint rhsId3 = rid + ((shift+2)%3)*p_Nfields*p_Np;

	for(iint fld=0; fld< p_Nfields; ++fld){
	  
	  //load q and update
	  if(fld<4)
	    s_q[n+fld*p_Np] = q[id+fld*p_Np] + ab1*rhsq[rhsId1+fld*p_Np]+ab2*rhsq[rhsId2+fld*p_Np]+ab3*rhsq[rhsId3+fld*p_Np];
	  else
	    s_q[n+fld*p_Np] = expdt*q[id+fld*p_Np] + saab1*(rhsq[rhsId1+fld*p_Np] + qCorr[rhsId1+fld*p_Np]) + saab2*(rhsq[rhsId2+fld*p_Np] + qCorr[rhsId2+fld*p_Np]) + saab3*(rhsq[rhsId3+fld*p_Np] + qCorr[rhsId3+fld*p_Np]);
	}
      }
    }
    // make sure all node data is loaded into shared
    barrier(localMemFence);
    for(iint n=0;n<p_StoVmaxNodes;++n;inner0){
      if(n<p_Nfaces*p_Nfp){

        const iint iid  = e*p_Nfp*p_Nfaces + n;
	const iint qidM = vmapM[iid] - e*p_Np;
	const iint qid  = e*p_Nfp*p_Nfaces*p_Nfields + n;

	for (iint fld = 0; fld < p_Nfields; ++fld){
	  fQM[qid+fld*p_Nfp*p_Nfaces] = s_q[qidM+fld*p_Np];
	}
      }

    }

  }
}
