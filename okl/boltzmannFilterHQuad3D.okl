kernel void boltzmannFilterHQuad3D(const iint Nelements,
				   const iint * restrict elementIds,
				   const iint * restrict shift,
				   const dfloat * restrict F,
				   const iint * restrict cubeFaceNumber,
				   const iint * restrict EToE,
				   const iint * restrict lev_updates,
				   const iint * restrict lev_numbers,
				   const iint l,
				   const dfloat * restrict qIn,
				   dfloat * restrict Fq) {
  
    for (iint eo = 0; eo < Nelements;++eo;outer0) {
    
	shared dfloat s_F[3][p_Nq][p_Nq];
	shared dfloat s_q[p_Nfields][3][p_Nq][p_Nq];
	exclusive iint eC;
	exclusive iint mark_edge;
	exclusive iint shiftl;
    
	for (iint j=0;j<p_Nq; ++j; inner1) {
	    for (iint i=0; i<p_Nq; ++i; inner0) {
		s_F[0][j][i] = F[i+0*p_Nq+j*3*p_Nq];
		s_F[1][j][i] = F[i+1*p_Nq+j*3*p_Nq];
		s_F[2][j][i] = F[i+2*p_Nq+j*3*p_Nq];

		shiftl = shift[l];

		eC = elementIds[eo];
		const iint eL = EToE[eC*p_Nfaces+3];
		const iint eR = EToE[eC*p_Nfaces+1];
		const iint eD = EToE[eC*p_Nfaces + 0];
		const iint eU = EToE[eC*p_Nfaces + 2];
	
		const iint faceC = cubeFaceNumber[eC];

		mark_edge = ((faceC==cubeFaceNumber[eL]) && (faceC==cubeFaceNumber[eR]) && (faceC==cubeFaceNumber[eD]) && (faceC==cubeFaceNumber[eU]));

		occaUnroll(p_Nfields)	  
		    for(iint fld=0;fld<p_Nfields;++fld){
			s_q[fld][1][j][i] = qIn[eC*p_Np*p_Nfields*p_nrhs + shiftl*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i];
			if(mark_edge) {

			    const iint levL = lev_numbers[eL];
			    const iint levR = lev_numbers[eR];
			    const dfloat stepC = lev_updates[l];
			    const dfloat stepL = lev_updates[levL];
			    const dfloat stepR = lev_updates[levR];
			    const iint shiftL = shift[levL];
			    const iint shiftR = shift[levR];
			    const dfloat sizeL = 1<<levL;
			    const dfloat sizeR = 1<<levR;	      

			    if (stepL != stepC) {
				dfloat q_sum = 0;		
				for (iint li=0; li<p_nrhs; ++li) {
				    const iint rhsNum = (shiftL + li) % p_nrhs;
				    dfloat q_prod = qIn[eL*p_Np*p_Nfields*p_nrhs + rhsNum*p_Np*p_Nfields + fld*p_Np+ j*p_Nq + i];
				    for (iint lj = 0; lj < p_nrhs; ++lj) {
					if (lj != li) {
					    q_prod *= (stepC - stepL + lj*sizeL)/(lj*sizeL - li*sizeL);
					}
				    }
				    q_sum += q_prod;
				}
				s_q[fld][0][j][i] = q_sum;
			    }
			    else {
				s_q[fld][0][j][i] = qIn[eL*p_Np*p_Nfields*p_nrhs + shiftL*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i];
			    }
			    if (stepR != stepC) {
				dfloat q_sum = 0;
				for (iint li=0; li<p_nrhs; ++li) {
				    const iint rhsNum = (shiftR + li) % p_nrhs;
				    dfloat q_prod = qIn[eR*p_Np*p_Nfields*p_nrhs + rhsNum*p_Np*p_Nfields + fld*p_Np+ j*p_Nq + i];
				    for (iint lj = 0; lj < p_nrhs; ++lj) {
					if (lj != li) {
					    q_prod *= (stepC - stepR + lj*sizeR)/(lj*sizeR - li*sizeR);
					}
				    }
				    q_sum += q_prod;
				}
				s_q[fld][2][j][i] = q_sum;
			    }
			    else {
				s_q[fld][2][j][i] = qIn[eR*p_Np*p_Nfields*p_nrhs + shiftR*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i];
			    }
			}
		    }
	    }
	}
	barrier(localMemFence);
	for (iint j=0;j<p_Nq; ++j; inner1) {
	    for (iint i=0; i<p_Nq; ++i; inner0) {
		dfloat Fqij[p_Nfields];
		if (mark_edge) {
	  
		    occaUnroll(p_Nfields)
			for(iint fld=0;fld<p_Nfields;++fld){
			    Fqij[fld] = 0;
			}
	  
		    occaUnroll(p_Nq)
			for(int n=0;n<p_Nq;++n){
			    // fetch once, use p_Nfields times
			    const dfloat FinL = s_F[0][i][n];
			    const dfloat FinC = s_F[1][i][n];
			    const dfloat FinR = s_F[2][i][n];
	      
			    // ratio of 1 shared per 2 flops: on P100 => 2TFLOPS max
			    occaUnroll(p_Nfields)
				for(iint fld=0;fld<p_Nfields;++fld){
				    Fqij[fld] += FinL*s_q[fld][0][j][n];
				    Fqij[fld] += FinC*s_q[fld][1][j][n];
				    Fqij[fld] += FinR*s_q[fld][2][j][n];
				}
			}
		}
		else{
	  
		    occaUnroll(p_Nfields)
			for(iint fld=0;fld<p_Nfields;++fld){
			    Fqij[fld] = s_q[fld][1][j][i];
			}
		}
	
		occaUnroll(p_Nfields)
		    for(iint fld=0;fld<p_Nfields;++fld){
			Fq[eC*p_Nfields*p_Np*p_nrhs + shiftl*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i] = Fqij[fld];
		    }
	    }
	}
    }
}


kernel void boltzmannFilterHLSERKQuad3D(const iint Nelements,
					const iint * restrict elementIDs,
					const iint saved,
					const iint shift,
					const dfloat * restrict F,
					const iint * restrict cubeFaceNumber,
					const iint * restrict EToE,
					const dfloat * restrict qIn,
					dfloat * restrict Fq,
					dfloat * restrict qpop) {
  
    for (iint e = 0; e < Nelements;++e;outer0) {
    
	shared dfloat s_F[3][p_Nq][p_Nq];
	shared dfloat s_q[p_Nfields][3][p_Nq][p_Nq];
	exclusive iint mark_edge;
	exclusive iint eo;
    
	for (iint j=0;j<p_Nq; ++j; inner1) {
	    for (iint i=0; i<p_Nq; ++i; inner0) {
		eo = elementIDs[e];
	
		s_F[0][j][i] = F[i+0*p_Nq+j*3*p_Nq];
		s_F[1][j][i] = F[i+1*p_Nq+j*3*p_Nq];
		s_F[2][j][i] = F[i+2*p_Nq+j*3*p_Nq];

		const iint eL = EToE[eo*p_Nfaces+3];
		const iint eR = EToE[eo*p_Nfaces+1];
		const iint eD = EToE[eo*p_Nfaces + 0];
		const iint eU = EToE[eo*p_Nfaces + 2];
	
		const iint faceC = cubeFaceNumber[eo];

		mark_edge = (faceC==cubeFaceNumber[eL])&&(faceC==cubeFaceNumber[eR]) &&(faceC==cubeFaceNumber[eD])&&(faceC==cubeFaceNumber[eU]);

		occaUnroll(p_Nfields)
		    for(iint fld=0;fld<p_Nfields;++fld){
			s_q[fld][1][j][i] = qIn[eo*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i];
			if(mark_edge) {
			    s_q[fld][0][j][i] = qIn[eL*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i];
			    s_q[fld][2][j][i] = qIn[eR*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i];
			}
		    }
	    }
	}
	barrier(localMemFence);
	for (iint j=0;j<p_Nq; ++j; inner1) {
	    for (iint i=0; i<p_Nq; ++i; inner0) {
		dfloat Fqij[p_Nfields];
		if (mark_edge) {
	  
		    occaUnroll(p_Nfields)
			for(iint fld=0;fld<p_Nfields;++fld){
			    Fqij[fld] = 0;
			}
	  
		    occaUnroll(p_Nq)
			for(int n=0;n<p_Nq;++n){
			    // fetch once, use p_Nfields times
			    const dfloat FinL = s_F[0][i][n];
			    const dfloat FinC = s_F[1][i][n];
			    const dfloat FinR = s_F[2][i][n];
	      
			    // ratio of 1 shared per 2 flops: on P100 => 2TFLOPS max
			    occaUnroll(p_Nfields)
				for(iint fld=0;fld<p_Nfields;++fld){
				    Fqij[fld] += FinL*s_q[fld][0][j][n];
				    Fqij[fld] += FinC*s_q[fld][1][j][n];
				    Fqij[fld] += FinR*s_q[fld][2][j][n];
				}
			}
		}
		else{
	  
		    occaUnroll(p_Nfields)
			for(iint fld=0;fld<p_Nfields;++fld){
			    Fqij[fld] = s_q[fld][1][j][i];
			}
		}
	
		occaUnroll(p_Nfields)
		    for(iint fld=0;fld<p_Nfields;++fld){
			Fq[eo*p_Nfields*p_Np + fld*p_Np + j*p_Nq + i] = Fqij[fld];
			if (saved)
			    qpop[eo*p_Np*p_Nfields*p_nrhs + shift*p_Np*p_Nfields + fld*p_Np+j*p_Nq+i] = s_q[fld][1][j][i];
		    }
	    }
	}
    }
}

kernel void boltzmannFilterHq0Quad3D(const iint Nelements,
				     const dfloat * restrict F,
				     const iint * restrict cubeFaceNumber,
				     const iint * restrict EToE,
				     const iint * restrict cubeDistance,
				     const dfloat * restrict qIn,
				     dfloat * restrict Fq) {
  
    for (iint eo = 0; eo < Nelements;++eo;outer0) {
    
	shared dfloat s_F[3][p_Nq][p_Nq];
	shared dfloat s_q[p_Nfields][3][p_Nq][p_Nq];
	exclusive iint mark_edge;
    
	for (iint j=0;j<p_Nq; ++j; inner1) {
	    for (iint i=0; i<p_Nq; ++i; inner0) {
		s_F[0][j][i] = F[i+0*p_Nq+j*3*p_Nq];
		s_F[1][j][i] = F[i+1*p_Nq+j*3*p_Nq];
		s_F[2][j][i] = F[i+2*p_Nq+j*3*p_Nq];

		const iint eL = EToE[eo*p_Nfaces + 3];
		const iint eR = EToE[eo*p_Nfaces + 1];
		const iint eD = EToE[eo*p_Nfaces + 0];
		const iint eU = EToE[eo*p_Nfaces + 2];
	
		const iint faceC = cubeFaceNumber[eo];

		//mark_edge = ((cubeDistance[eo] > 1)&&
		//    (cubeDistance[eL] > 0)&&
		//    (cubeDistance[eR] > 0));
	
		mark_edge = ((faceC==cubeFaceNumber[eL])&&
			     (faceC==cubeFaceNumber[eR]));//&&
		//		     (faceC==cubeFaceNumber[eD])&&
		//	     (faceC==cubeFaceNumber[eU]));
	
		occaUnroll(p_Nfields)
		    for(iint fld=0;fld<p_Nfields;++fld){
			int id = eo*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i;
			dfloat qin = qIn[id];
			s_q[fld][1][j][i] = qin;
			if(mark_edge) {
			    s_q[fld][0][j][i] = qIn[eL*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i];
			    s_q[fld][2][j][i] = qIn[eR*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i];
			}
		    }
	    }
	}
    
	barrier(localMemFence);

	for (iint j=0;j<p_Nq; ++j; inner1) {
	    for (iint i=0; i<p_Nq; ++i; inner0) {
		dfloat Fqij[p_Nfields];
	
		if (mark_edge) {
	  
		    occaUnroll(p_Nfields)
			for(iint fld=0;fld<p_Nfields;++fld){
			    Fqij[fld] = 0;
			}
	  
		    occaUnroll(p_Nq)
			for(int n=0;n<p_Nq;++n){
			    // fetch once, use p_Nfields times
			    const dfloat FinL = s_F[0][i][n];
			    const dfloat FinC = s_F[1][i][n];
			    const dfloat FinR = s_F[2][i][n];
	      
			    // ratio of 1 shared per 2 flops: on P100 => 2TFLOPS max
			    occaUnroll(p_Nfields)
				for(iint fld=0;fld<p_Nfields;++fld){
				    Fqij[fld] += FinL*s_q[fld][0][j][n];
				    Fqij[fld] += FinC*s_q[fld][1][j][n];
				    Fqij[fld] += FinR*s_q[fld][2][j][n];
				}
			}

		}
		else{
		    occaUnroll(p_Nfields)
			for(iint fld=0;fld<p_Nfields;++fld){
			    Fqij[fld] = s_q[fld][1][j][i];
			}
		}
	
		occaUnroll(p_Nfields)
		    for(iint fld=0;fld<p_Nfields;++fld){
			Fq[eo*p_Nfields*p_Np + fld*p_Np + j*p_Nq + i] = Fqij[fld];
		    }
	    }
	}
    }
}

kernel void boltzmannFilterHtransTraceQuad3D(const iint Nelements,
					const dfloat * restrict F,
					const dfloat * restrict Finv,
					const iint * restrict cubeFaceNumber,
					const iint * restrict EToE,
					const dfloat * restrict vgeo,
					const iint * restrict cubeDistance,
					const dfloat * restrict qIn,
					dfloat * restrict Fq) {
  
    for (iint eo = 0; eo < Nelements;++eo;outer0) {
    
	shared dfloat s_F[4][p_Nq][p_Nq];
	shared dfloat s_q[p_Nfields][6][p_Nq][p_Nq];
	shared dfloat s_qtemp[p_Nfields][3][p_Nq][p_Nq];
	exclusive iint mark_edge;
	exclusive iint dir;
	
	for (iint j=0;j<p_Nq; ++j; inner1) {
	    for (iint i=0; i<p_Nq; ++i; inner0) {
		dir = 2;
		
		s_F[0][j][i] = F[i+2*p_Nq+j*3*p_Nq];
		s_F[1][j][i] = F[i+1*p_Nq+j*3*p_Nq];
		s_F[2][j][i] = F[i+0*p_Nq+j*3*p_Nq];
		
		//horizontal indexing
		const iint eL = EToE[eo*p_Nfaces + 3];
		const iint eR = EToE[eo*p_Nfaces + 1]; 
		const iint eD = EToE[eo*p_Nfaces + 0]; 
		const iint eU = EToE[eo*p_Nfaces + 2]; 

		const iint eDL = EToE[eL*p_Nfaces + 0];
		const iint eUL = EToE[eL*p_Nfaces + 2];
		const iint eDR = EToE[eR*p_Nfaces + 0];
		const iint eUR = EToE[eR*p_Nfaces + 2];
		
		const iint faceC = cubeFaceNumber[eo];

		mark_edge = ((faceC==cubeFaceNumber[eL])&&
			     (faceC==cubeFaceNumber[eR])&&
			     (faceC==cubeFaceNumber[eD])&&
			     (faceC==cubeFaceNumber[eU]));		    
		
		occaUnroll(p_Nfields)
		    for(iint fld=0;fld<p_Nfields;++fld){
			occaUnroll(3)
			    for (int d = 0; d < 3; ++d) {
				s_qtemp[fld][d][j][i] = 0.f;
			    }
			const dfloat wj = vgeo[eo*p_Np*p_Nvgeo + 9*p_Np + j*p_Nq + i];

			int id = eo*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i;
			dfloat qin = qIn[id];
			s_q[fld][1][j][i] = qin;				
			
			if (!mark_edge) {
			    if (cubeDistance[eL] > 0) {
				const dfloat wjdl = vgeo[eDL*p_Np*p_Nvgeo + 9*p_Np + j*p_Nq + i];
				const dfloat wjl = vgeo[eL*p_Np*p_Nvgeo + 9*p_Np + j*p_Nq + i];
				const dfloat wjul = vgeo[eUL*p_Np*p_Nvgeo + 9*p_Np + j*p_Nq + i];

				s_q[fld][3][j][i] = (cubeDistance[eDL] > 0) ? qIn[eDL*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i] : 0.f;
				s_q[fld][4][j][i] = qIn[eL*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i];
				s_q[fld][5][j][i] = (cubeDistance[eUL] > 0) ? qIn[eUL*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i] : 0.f;
				s_F[3][j][i] = s_F[0][j][i];
				dir = 0;
			    }
			    else if (cubeDistance[eD] > 0) {
				const dfloat wjd = vgeo[eD*p_Np*p_Nvgeo + 9*p_Np + j*p_Nq + i];

				s_q[fld][0][j][i] = qIn[eD*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i];
				s_F[3][j][i] = s_F[0][j][i];
				dir = 1;
			    }
			    
			    else if (cubeDistance[eR] > 0) {
				const dfloat wjdr = vgeo[eDR*p_Np*p_Nvgeo + 9*p_Np + j*p_Nq + i];
				const dfloat wjr = vgeo[eR*p_Np*p_Nvgeo + 9*p_Np + j*p_Nq + i];
				const dfloat wjur = vgeo[eUR*p_Np*p_Nvgeo + 9*p_Np + j*p_Nq + i];

				s_q[fld][3][j][i] = (cubeDistance[eDR] > 0) ? qIn[eDR*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i] : 0.f;
				s_q[fld][4][j][i] = qIn[eR*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i];
				s_q[fld][5][j][i] = (cubeDistance[eUR] > 0) ? qIn[eUR*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i] : 0.f;
				s_F[3][j][i] = s_F[2][j][i];
				dir = 0;
			    }
			    else if (cubeDistance[eU] > 0) {
				const dfloat wju = vgeo[eU*p_Np*p_Nvgeo + 9*p_Np + j*p_Nq + i];
				s_q[fld][0][j][i] = qIn[eU*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i];
				s_F[3][j][i] = s_F[2][j][i];
				dir = 1;
			    }
			}
		    }
	    }
	}

    	barrier(localMemFence);

	for (iint j=0;j<p_Nq; ++j; inner1) {
	    for (iint i=0; i<p_Nq; ++i; inner0) {
		    //horizontal
		    if (!mark_edge && dir == 0) {
			occaUnroll(p_Nq)
			    for(int n=0;n<p_Nq;++n){
				// fetch once, use p_Nfields times
				const dfloat FinS = s_F[3][i][n];
				
				// ratio of 1 shared per 2 flops: on P100 => 2TFLOPS max
				occaUnroll(p_Nfields)
				    for(iint fld=0;fld<p_Nfields;++fld){
					s_qtemp[fld][0][j][i] += FinS*s_q[fld][3][j][n];
				        s_qtemp[fld][1][j][i] += FinS*s_q[fld][4][j][n];
					s_qtemp[fld][2][j][i] += FinS*s_q[fld][5][j][n];
				    }
			    }
		    }
	    }
	}
	
	barrier(localMemFence);
	
	for (iint j=0;j<p_Nq; ++j; inner1) {
	    for (iint i=0; i<p_Nq; ++i; inner0) {
		dfloat Fqij[p_Nfields];
		
		occaUnroll(p_Nfields)
		    for(iint fld=0;fld<p_Nfields;++fld){
			Fqij[fld] = s_q[fld][1][j][i];
		    }
		
		if (!mark_edge) {
		    //vertical
		    if (dir == 1) {
			occaUnroll(p_Nq)
			    for(int n=0;n<p_Nq;++n){
				// fetch once, use p_Nfields times
				const dfloat FinS = s_F[3][j][n];
				
				// ratio of 1 shared per 2 flops: on P100 => 2TFLOPS max
				occaUnroll(p_Nfields)
				    for(iint fld=0;fld<p_Nfields;++fld){
					Fqij[fld] += FinS*s_q[fld][0][n][i];
				    }
			    }
		    }
		    //horizontal
		    else if (dir == 0) {
			occaUnroll(p_Nq)
			    for(int n=0;n<p_Nq;++n){
				// fetch once, use p_Nfields times
				const dfloat FinL = s_F[0][j][n];
				const dfloat FinC = s_F[1][j][n];
				const dfloat FinR = s_F[2][j][n];
				
				// ratio of 1 shared per 2 flops: on P100 => 2TFLOPS max
				occaUnroll(p_Nfields)
				    for(iint fld=0;fld<p_Nfields;++fld){
					Fqij[fld] += FinL*s_qtemp[fld][0][n][i];
					Fqij[fld] += FinC*s_qtemp[fld][1][n][i];
					Fqij[fld] += FinR*s_qtemp[fld][2][n][i];
				    }
			    }
		    }			
		    
		    const dfloat wj = vgeo[eo*p_Np*p_Nvgeo + 10*p_Np + j*p_Nq + i];
		    
		    occaUnroll(p_Nfields)
			for(iint fld=0;fld<p_Nfields;++fld){
			    Fq[eo*p_Nfields*p_Np + fld*p_Np + j*p_Nq + i] = Fqij[fld];
			}
		}
	    }
	}
    }
}

kernel void boltzmannFilterHtransQuad3D(const iint Nelements,
					const dfloat * restrict F,
					const dfloat * restrict Finv,
					const iint * restrict cubeFaceNumber,
					const iint * restrict EToE,
					const dfloat * restrict vgeo,
					const iint * restrict cubeDistance,
					const dfloat * restrict qIn,
					dfloat * restrict Fq) {
  
    for (iint eo = 0; eo < Nelements;++eo;outer0) {
    
	shared dfloat s_F[3][p_Nq][p_Nq];
	shared dfloat s_q[p_Nfields][3][p_Nq][p_Nq];
	exclusive iint mark_edge;
	
	for (iint j=0;j<p_Nq; ++j; inner1) {
	    for (iint i=0; i<p_Nq; ++i; inner0) {
		const dfloat wj = vgeo[eo*p_Np*p_Nvgeo + 9*p_Np + j*p_Nq + i];
		
		s_F[0][j][i] = F[i+2*p_Nq+j*3*p_Nq];
		s_F[1][j][i] = F[i+1*p_Nq+j*3*p_Nq];
		s_F[2][j][i] = F[i+0*p_Nq+j*3*p_Nq];
		
		const iint eL = EToE[eo*p_Nfaces + 3];
		const iint eR = EToE[eo*p_Nfaces + 1]; 
		const iint eD = EToE[eo*p_Nfaces + 0]; 
		const iint eU = EToE[eo*p_Nfaces + 2]; 
	
		const iint faceC = cubeFaceNumber[eo];

		mark_edge = ((faceC==cubeFaceNumber[eL])&&
			     (faceC==cubeFaceNumber[eR])&&
			     (faceC==cubeFaceNumber[eD])&&
			     (faceC==cubeFaceNumber[eU]));
		
		occaUnroll(p_Nfields)
		    for(iint fld=0;fld<p_Nfields;++fld){
			int id = eo*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i;
			dfloat qin = qIn[id];
			s_q[fld][1][j][i] = qin;
			    
			if (cubeDistance[eL] > 0) {
			    const dfloat wjl = vgeo[eL*p_Np*p_Nvgeo + 9*p_Np + j*p_Nq + i];
			    s_q[fld][0][j][i] = qIn[eL*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i];
			}
			else {
			    s_q[fld][0][j][i] = 0.f;
			}
			    
			if (cubeDistance[eR] > 0) {
			    const dfloat wjr = vgeo[eR*p_Np*p_Nvgeo + 9*p_Np + j*p_Nq + i];
			    s_q[fld][2][j][i] = qIn[eR*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i];
			}
			else {
			    s_q[fld][2][j][i] = 0.f;
			}
		    }
	    }
	}

    	barrier(localMemFence);

	for (iint j=0;j<p_Nq; ++j; inner1) {
	    for (iint i=0; i<p_Nq; ++i; inner0) {
		dfloat Fqij[p_Nfields];

		if (mark_edge) {
		    occaUnroll(p_Nfields)
			for(iint fld=0;fld<p_Nfields;++fld){
			    Fqij[fld] = 0;
			}
	  
		    occaUnroll(p_Nq)
			for(int n=0;n<p_Nq;++n){
			    // fetch once, use p_Nfields times
			    const dfloat FinL = s_F[0][i][n];
			    const dfloat FinC = s_F[1][i][n];
			    const dfloat FinR = s_F[2][i][n];
			
			    // ratio of 1 shared per 2 flops: on P100 => 2TFLOPS max
			    occaUnroll(p_Nfields)
				for(iint fld=0;fld<p_Nfields;++fld){
				    Fqij[fld] += FinL*s_q[fld][0][j][n];
				    Fqij[fld] += FinC*s_q[fld][1][j][n];
				    Fqij[fld] += FinR*s_q[fld][2][j][n];
				}
			}
		}
		else{
		    occaUnroll(p_Nfields)
			for(iint fld=0;fld<p_Nfields;++fld){
			    Fqij[fld] = s_q[fld][1][j][i];
			}
		}
				
		occaUnroll(p_Nfields)
		    for(iint fld=0;fld<p_Nfields;++fld){
			Fq[eo*p_Nfields*p_Np + fld*p_Np + j*p_Nq + i] = Fqij[fld];
		    }
	    }
	}
    }
}

kernel void boltzmannFilterHsymQuad3D(const iint Nelements,
				      const dfloat * restrict F,
				      const iint * restrict cubeFaceNumber,
				      const iint * restrict EToE,
				      const dfloat * restrict vgeo,
				      const iint * restrict cubeDistance,
				      const dfloat * restrict qIn,
				      dfloat * restrict Fq) {
  
    for (iint eo = 0; eo < Nelements;++eo;outer0) {
    
	shared dfloat s_F[3][p_Nq][p_Nq];
	shared dfloat s_q[p_Nfields][3][p_Nq][p_Nq];
	exclusive iint mark_edge;
    
	for (iint j=0;j<p_Nq; ++j; inner1) {
	    for (iint i=0; i<p_Nq; ++i; inner0) {
		s_F[0][j][i] = F[i+0*p_Nq+j*3*p_Nq];
		s_F[1][j][i] = F[i+1*p_Nq+j*3*p_Nq];
		s_F[2][j][i] = F[i+2*p_Nq+j*3*p_Nq];

		const iint eL = EToE[eo*p_Nfaces + 3];
		const iint eR = EToE[eo*p_Nfaces + 1];
		const iint eD = EToE[eo*p_Nfaces + 0];
		const iint eU = EToE[eo*p_Nfaces + 2];
	
		const iint faceC = cubeFaceNumber[eo];
			
		mark_edge = ((faceC==cubeFaceNumber[eL])&&
			     (faceC==cubeFaceNumber[eR])&&
			     (faceC==cubeFaceNumber[eD])&&
			     (faceC==cubeFaceNumber[eU]));
	
		occaUnroll(p_Nfields)
		    for(iint fld=0;fld<p_Nfields;++fld){
			int id = eo*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i;
			const dfloat wj = vgeo[eo*p_Np*p_Nvgeo + 10*p_Np + j*p_Nq + i];
			dfloat qin = qIn[id];
			s_q[fld][1][j][i] = qin;
			if(mark_edge) {
			    const dfloat wjl = vgeo[eL*p_Np*p_Nvgeo + 10*p_Np + j*p_Nq + i];
			    const dfloat wjr = vgeo[eR*p_Np*p_Nvgeo + 10*p_Np + j*p_Nq + i];
			    s_q[fld][0][j][i] = qIn[eL*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i];
			    s_q[fld][2][j][i] = qIn[eR*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i];
			}
		    }
	    }
	}
	
	barrier(localMemFence);

	for (iint j=0;j<p_Nq; ++j; inner1) {
	    for (iint i=0; i<p_Nq; ++i; inner0) {
		dfloat Fqij[p_Nfields];
	
		if (mark_edge) {
	  
		    occaUnroll(p_Nfields)
			for(iint fld=0;fld<p_Nfields;++fld){
			    Fqij[fld] = 0;
			}
	  
		    occaUnroll(p_Nq)
			for(int n=0;n<p_Nq;++n){
			    // fetch once, use p_Nfields times
			    const dfloat FinL = s_F[0][i][n];
			    const dfloat FinC = s_F[1][i][n];
			    const dfloat FinR = s_F[2][i][n];
	      
			    // ratio of 1 shared per 2 flops: on P100 => 2TFLOPS max
			    occaUnroll(p_Nfields)
				for(iint fld=0;fld<p_Nfields;++fld){
				    Fqij[fld] += FinL*s_q[fld][0][j][n];
				    Fqij[fld] += FinC*s_q[fld][1][j][n];
				    Fqij[fld] += FinR*s_q[fld][2][j][n];
				}
			}

		}
		else{
		    occaUnroll(p_Nfields)
			for(iint fld=0;fld<p_Nfields;++fld){
			    Fqij[fld] = s_q[fld][1][j][i];
			}
		}

		const dfloat wj = vgeo[eo*p_Np*p_Nvgeo + 10*p_Np + j*p_Nq + i];
	
		occaUnroll(p_Nfields)
		    for(iint fld=0;fld<p_Nfields;++fld){
			Fq[eo*p_Nfields*p_Np + fld*p_Np + j*p_Nq + i] = Fqij[fld];
		    }
	    }
	}
    }
}

kernel void boltzmannFilterHglobalQuad3D(const iint Nelements,
					 const iint NgridElements,
					 const dfloat * restrict F,
					 const iint * restrict cubeFaceNumber,
					 const iint * restrict EToE,
					 const dfloat * restrict qIn,
					 dfloat * restrict Fq) {
  
    for (iint eo = 0; eo < NgridElements;++eo;outer0) {
    
	shared dfloat s_F[3][p_Nq][p_Nq];
	shared dfloat s_q[p_Nfields][3][p_Nq][p_Nq];
    
	for (iint j=0;j<p_Nq; ++j; inner1) {
	    for (iint i=0; i<p_Nq; ++i; inner0) {
		if (eo < Nelements) {
		    s_F[0][j][i] = F[i+0*p_Nq+j*3*p_Nq];
		    s_F[1][j][i] = F[i+1*p_Nq+j*3*p_Nq];
		    s_F[2][j][i] = F[i+2*p_Nq+j*3*p_Nq];
	  
		    const iint eL = EToE[eo*p_Nfaces + 3];
		    const iint eR = EToE[eo*p_Nfaces + 1];
		    const iint eD = EToE[eo*p_Nfaces + 0];
		    const iint eU = EToE[eo*p_Nfaces + 2];
	  
		    const iint faceC = cubeFaceNumber[eo];
	  
		    occaUnroll(p_Nfields)
			for(iint fld=0;fld<p_Nfields;++fld){
			    int id = eo*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i;
			    dfloat qin = qIn[id];
			    s_q[fld][1][j][i] = qin;
			    s_q[fld][0][j][i] = qIn[eL*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i];
			    s_q[fld][2][j][i] = qIn[eR*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i];
			}
		}
	    }
	}
    
	barrier(localMemFence);
    
	for (iint j=0;j<p_Nq; ++j; inner1) {
	    for (iint i=0; i<p_Nq; ++i; inner0) {
		if (eo < Nelements) {
		    dfloat Fqij[p_Nfields];	  
		    occaUnroll(p_Nfields)
			for(iint fld=0;fld<p_Nfields;++fld){
			    Fqij[fld] = 0;
			}
	  
		    occaUnroll(p_Nq)
			for(int n=0;n<p_Nq;++n){
			    // fetch once, use p_Nfields times
			    const dfloat FinL = s_F[0][i][n];
			    const dfloat FinC = s_F[1][i][n];
			    const dfloat FinR = s_F[2][i][n];
	      
			    // ratio of 1 shared per 2 flops: on P100 => 2TFLOPS max
			    occaUnroll(p_Nfields)
				for(iint fld=0;fld<p_Nfields;++fld){
				    Fqij[fld] += FinL*s_q[fld][0][j][n];
				    Fqij[fld] += FinC*s_q[fld][1][j][n];
				    Fqij[fld] += FinR*s_q[fld][2][j][n];
				}
			}
	  
		    occaUnroll(p_Nfields)
			for(iint fld=0;fld<p_Nfields;++fld){
			    Fq[eo*p_Nfields*p_Np + fld*p_Np + j*p_Nq + i] = Fqij[fld];
			}
		}
	    }
	}
    }
}

kernel void boltzmannFilterLevelsHQuad3D(const iint Nelements,
					 const iint * restrict elementIDs,
					 const dfloat * restrict F,
					 const iint * restrict cubeFaceNumber,
					 const iint * restrict EToE,
					 const dfloat * restrict qIn,
					 dfloat * restrict Fq) {
  
    for (iint e = 0; e < Nelements;++e;outer0) {
    
	shared dfloat s_F[3][p_Nq][p_Nq];
	shared dfloat s_q[p_Nfields][3][p_Nq][p_Nq];
	exclusive iint mark_edge;
	exclusive iint eo;
    
	for (iint j=0;j<p_Nq; ++j; inner1) {
	    for (iint i=0; i<p_Nq; ++i; inner0) {
		eo = elementIDs[e];
	
		s_F[0][j][i] = F[i+0*p_Nq+j*3*p_Nq];
		s_F[1][j][i] = F[i+1*p_Nq+j*3*p_Nq];
		s_F[2][j][i] = F[i+2*p_Nq+j*3*p_Nq];

		const iint eL = EToE[eo*p_Nfaces + 3];
		const iint eR = EToE[eo*p_Nfaces + 1];
		const iint eD = EToE[eo*p_Nfaces + 0];
		const iint eU = EToE[eo*p_Nfaces + 2];
	
		const iint faceC = cubeFaceNumber[eo];

		mark_edge = ((faceC==cubeFaceNumber[eL])&&
			     (faceC==cubeFaceNumber[eR])&&
			     (faceC==cubeFaceNumber[eD])&&
			     (faceC==cubeFaceNumber[eU]));

		occaUnroll(p_Nfields)
		    for(iint fld=0;fld<p_Nfields;++fld){
			int id = eo*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i;
			dfloat qin = qIn[id];
			s_q[fld][1][j][i] = qin;
			if(mark_edge) {
			    s_q[fld][0][j][i] = qIn[eL*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i];
			    s_q[fld][2][j][i] = qIn[eR*p_Np*p_Nfields + fld*p_Np + j*p_Nq + i];
			}
		    }
	    }
	}
    
	barrier(localMemFence);

	for (iint j=0;j<p_Nq; ++j; inner1) {
	    for (iint i=0; i<p_Nq; ++i; inner0) {
		dfloat Fqij[p_Nfields];
		if (mark_edge) {
	  
		    occaUnroll(p_Nfields)
			for(iint fld=0;fld<p_Nfields;++fld){
			    Fqij[fld] = 0;
			}
	  
		    occaUnroll(p_Nq)
			for(int n=0;n<p_Nq;++n){
			    // fetch once, use p_Nfields times
			    const dfloat FinL = s_F[0][i][n];
			    const dfloat FinC = s_F[1][i][n];
			    const dfloat FinR = s_F[2][i][n];
	      
			    // ratio of 1 shared per 2 flops: on P100 => 2TFLOPS max
			    occaUnroll(p_Nfields)
				for(iint fld=0;fld<p_Nfields;++fld){
				    Fqij[fld] += FinL*s_q[fld][0][j][n];
				    Fqij[fld] += FinC*s_q[fld][1][j][n];
				    Fqij[fld] += FinR*s_q[fld][2][j][n];
				}
			}

		}
		else{
	  
		    occaUnroll(p_Nfields)
			for(iint fld=0;fld<p_Nfields;++fld){
			    Fqij[fld] = s_q[fld][1][j][i];
			}
		}
	
		occaUnroll(p_Nfields)
		    for(iint fld=0;fld<p_Nfields;++fld){
			Fq[eo*p_Nfields*p_Np + fld*p_Np + j*p_Nq + i] = Fqij[fld];
		    }
	    }
	}
    }
}
