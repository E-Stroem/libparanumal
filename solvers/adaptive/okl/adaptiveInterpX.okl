
@kernel void adaptiveInterpX(const dlong Nelements,
			     @restrict const dlong  * EToC,
			     @restrict const dfloat * Pb,
			     @restrict const dfloat * Pt,
			     @restrict dfloat * vgeo){
  
  for (dlong eo = 0; eo < Nelements; eo += p_NelementsblkS; @outer(0)){
    
    @shared dfloat s_x[p_DIM][p_NelementsblkS][p_Nqk][p_Nq];
    @shared dfloat s_y[p_DIM][p_NelementsblkS][p_Nqk][p_Nq];
    @shared dfloat s_z[p_DIM][p_NelementsblkS][p_Nqk][p_Nq];

    @shared dfloat s_Pb[p_Nq][p_Nq];
    @shared dfloat s_Pt[p_Nq][p_Nq];
    
    @exclusive dlong e;
    
    @exclusive int hf[p_P4EST_FACES];
    @exclusive int hg[p_P4EST_EDGES];
    
    // Load shared memory
    for (dlong ei = 0; ei < p_NelementsblkS; ++ei; @inner(2)){
      for (dlong n = 0; n < p_Nqk; ++n; @inner(1)){
        for (dlong m = 0; m < p_Nq; ++m; @inner(0)){
          e = eo + ei;
	  
          if (ei == 0){
            for (dlong j = n; j < p_Nq; j += p_Nqk)
              for (dlong i = m; i < p_Nq; i += p_Nq){
		const dlong id = j * p_Nq + i;
		s_Pb[j][i] = Pb[id];
		s_Pt[j][i] = Pt[id];
              }
	  }
	  
          for (int f = 0; f < p_P4EST_FACES; ++f){
            hf[f] = -1;
	  }
	  
          for (int g = 0; g < p_P4EST_EDGES; ++g){
            hg[g] = -1;
	  }

          const dlong fc = (e < Nelements) ? EToC[e] : 0;

          if (fc){
	    
            const dlong c = fc & 0x0007;
            dlong work = fc >> 3;
            dlong cwork = c;

            for (int o = 0; o < 3; ++o){
              if (work & 0x0001){
                const int f = p8est_corner_faces[c][o];
                hf[f] = p8est_corner_face_corners[c][f];
                for (int p = 0; p < 4; ++p){
		  const int g = p8est_face_edges[f][p];
		  hg[g] = 4;
		}
              }
              work >>= 1;
            }
	    
            for (int o = 0; o < 3; ++o){
              if (work & 0x0001){
		const int g = p8est_corner_edges[c][o];
		hg[g] = (hg[g] == -1) ? 0 : 2;
                hg[g] += (int)(cwork & 0x0001);
              }
              cwork >>= 1;
              work >>= 1;
            }
          }
        }
      }
    }
    
    @barrier("local");
    
    for (dlong ei = 0; ei < p_NelementsblkS; ++ei; @inner(2)){
      for (dlong n = 0; n < p_Nqk; ++n; @inner(1)){
	for (dlong m = 0; m < p_Nq; ++m; @inner(0)){
	  int hi = 0;
	  
	  for (int f = 0; f < p_P4EST_FACES; ++f){
            if (hf[f] >= 0){
	      const dlong l = fmask(m, n, f);
	      const dlong id = l + e * p_Np * p_NVGEO;
	      
	      s_x[hi][ei][n][m] = vgeo[id + p_VGEO_X * p_Np];
	      s_y[hi][ei][n][m] = vgeo[id + p_VGEO_Y * p_Np];
	      s_z[hi][ei][n][m] = vgeo[id + p_VGEO_Z * p_Np];
	      ++hi;
	    }
	  }
	}
      }
    }
    
    @barrier("local");
    
    for (dlong ei = 0; ei < p_NelementsblkS; ++ei; @inner(2)){
      for (dlong n = 0; n < p_Nqk; ++n; @inner(1)){
	for (dlong m = 0; m < p_Nq; ++m; @inner(0)){
	  int hi = 0;
	  for (int f = 0; f < p_P4EST_FACES; ++f){
            if (hf[f] >= 0){
	      
              dfloat x = ZERO, y = ZERO, z = ZERO;
	      
              if (hf[f] == 0){
                for (dlong p = 0; p < p_Nq; ++p){

#pragma unroll p_Nq
		  for (dlong o = 0; o < p_Nq; ++o){
		    x += s_Pb[m][o] * s_Pb[n][p] * s_x[hi][ei][p][o];
		    y += s_Pb[m][o] * s_Pb[n][p] * s_y[hi][ei][p][o];
		    z += s_Pb[m][o] * s_Pb[n][p] * s_z[hi][ei][p][o];
		  }
                }
	      }
	      
              if (hf[f] == 1){
                for (dlong p = 0; p < p_Nq; ++p){
#pragma unroll p_Nq
		  for (dlong o = 0; o < p_Nq; ++o){
		    x += s_Pt[m][o] * s_Pb[n][p] * s_x[hi][ei][p][o];
		    y += s_Pt[m][o] * s_Pb[n][p] * s_y[hi][ei][p][o];
		    z += s_Pt[m][o] * s_Pb[n][p] * s_z[hi][ei][p][o];
		  }
                }
	      }
	      
	      
              if (hf[f] == 2){
                for (dlong p = 0; p < p_Nq; ++p){
#pragma unroll p_Nq
		  for (dlong o = 0; o < p_Nq; ++o){
		    x += s_Pb[m][o] * s_Pt[n][p] * s_x[hi][ei][p][o];
		    y += s_Pb[m][o] * s_Pt[n][p] * s_y[hi][ei][p][o];
		    z += s_Pb[m][o] * s_Pt[n][p] * s_z[hi][ei][p][o];
		  }
                }
	      }

              if (hf[f] == 3){
                for (dlong p = 0; p < p_Nq; ++p){
#pragma unroll p_Nq
		    for (dlong o = 0; o < p_Nq; ++o){
		      x += s_Pt[m][o] * s_Pt[n][p] * s_x[hi][ei][p][o];
		      y += s_Pt[m][o] * s_Pt[n][p] * s_y[hi][ei][p][o];
		      z += s_Pt[m][o] * s_Pt[n][p] * s_z[hi][ei][p][o];
		    }
                }
	      }
	      
              const dlong l = fmask(m, n, f);
              const dlong id = l + e * p_Np * p_NVGEO;
	      
              vgeo[id + p_VGEO_X * p_Np] = x;
              vgeo[id + p_VGEO_Y * p_Np] = y;
              vgeo[id + p_VGEO_Z * p_Np] = z;
	      
              ++hi;
            }
	  }
	}
      }
    }
    
    @barrier("local");
    
    for (dlong ei = 0; ei < p_NelementsblkS; ++ei; @inner(2)){
      for (dlong n = 0; n < p_Nqk; ++n; @inner(1)){
	for (dlong m = 0; m < p_Nq; ++m; @inner(0)){
	  for (int g = 0; g < p_P4EST_EDGES; ++g){
	    
            if (n == 0 && (hg[g] == 0 || hg[g] == 1)){
              const dlong l = gmask(m, g);
              const dlong id = l + e * p_Np * p_NVGEO;
	      
              s_x[hi][ei][n][m] = vgeo[id + p_VGEO_X * p_Np];
              s_y[hi][ei][n][m] = vgeo[id + p_VGEO_Y * p_Np];
              s_z[hi][ei][n][m] = vgeo[id + p_VGEO_Z * p_Np];
	      
              ++hi;
            }
	  }
	}
      }
    }
    
    @barrier("local");
    
    for (dlong ei = 0; ei < p_NelementsblkS; ++ei; @inner(2)){
      for (dlong n = 0; n < p_Nqk; ++n; @inner(1)){
	for (dlong m = 0; m < p_Nq; ++m; @inner(0)){
	  for (int g = 0; g < p_P4EST_EDGES; ++g){
            if (n == 0 && (hg[g] == 0 || hg[g] == 1)){
              dfloat x = ZERO, y = ZERO, z = ZERO;
	      
              if (hg[g] == 0){
#pragma unroll p_Nq
		for (dlong p = 0; p < p_Nq; ++p){
		  x += s_Pb[m][p] * s_x[hi][ei][n][p];
		  y += s_Pb[m][p] * s_y[hi][ei][n][p];
		  z += s_Pb[m][p] * s_z[hi][ei][n][p];
		}
              }
	      
              if (hg[g] == 1){
#pragma unroll p_Nq
		for (dlong p = 0; p < p_Nq; ++p){
		  x += s_Pt[m][p] * s_x[hi][ei][n][p];
		  y += s_Pt[m][p] * s_y[hi][ei][n][p];
		  z += s_Pt[m][p] * s_z[hi][ei][n][p];
		}
              }
	      
              const dlong l = gmask(m, g);
              const dlong id = l + e * p_Np * p_NVGEO;
	      
              vgeo[id + p_VGEO_X * p_Np] = x;
              vgeo[id + p_VGEO_Y * p_Np] = y;
              vgeo[id + p_VGEO_Z * p_Np] = z;
	      
              ++hi;
            }
	  }
	}
      }
    }
  }
}
