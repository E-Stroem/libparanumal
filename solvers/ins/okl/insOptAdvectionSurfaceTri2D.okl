@kernel void insSubCycleCubatureSurfaceTri2D_v0(dlong Nelements,
                                            dfloat *  vgeo,
                                            dfloat *  sgeo,
                                            dfloat *  cubsgeo,
                                            dfloat *  intInterpT, // interpolate to integration nodes
                                            dfloat *  intLIFTT, // lift from integration to interpolation nodes
                                            dfloat *  cubInterpT,
                                            dfloat *  cubProjectT,
                                            dlong  *  vmapM,
                                            dlong  *  vmapP,
																						int    *  EToB,
																						dfloat bScale,
																						dfloat time,
                                            dfloat *  intx, // integration nodes
                                            dfloat *  inty,
                                            dfloat *  intz,
                                                       dlong offset,
                                            dfloat *  U,
                                            dfloat *  Ud,
                                            dfloat *  rhsU){
  // for all elements
  for(dlong e=0;e<Nelements;++e;@outer(0)){

    @shared dfloat s_iFluxU[p_intNfpNfaces];
    @shared dfloat s_iFluxV[p_intNfpNfaces];

    for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 

      if(e<Nelements){
        if(n<(p_Nfaces*p_intNfp)){

          int face = n/p_intNfp; // find face that owns this integration node

          // load surface geofactors for this face
          dlong sid    = p_Nsgeo*(e*p_Nfaces+face);
          dfloat nx   = sgeo[sid+p_NXID];
          dfloat ny   = sgeo[sid+p_NYID];
          dfloat sJ   = sgeo[sid+p_SJID];
          dfloat invJ = sgeo[sid+p_IJID];

          dfloat iUM  = 0.f, iVM  = 0.f;
          dfloat iUP  = 0.f, iVP  = 0.f;
          dfloat iUdM = 0.f, iVdM = 0.f;
          dfloat iUdP = 0.f, iVdP = 0.f;

          // local block interpolation (face nodes to integration nodes)
          //#pragma unroll p_Nfp
					for(int m=0;m<p_Nfp;++m){
						dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];

						dlong id  = e*p_Nfp*p_Nfaces + face*p_Nfp + m;
						dlong idM = vmapM[id];
						dlong idP = vmapP[id];
						//
						iUM  += iInm*U[idM  + 0*offset];
						iVM  += iInm*U[idM  + 1*offset];
						iUdM += iInm*Ud[idM + 0*offset];
						iVdM += iInm*Ud[idM + 1*offset];

						iUP  += iInm*U[idP  + 0*offset];
						iVP  += iInm*U[idP  + 1*offset];
						iUdP += iInm*Ud[idP + 0*offset];
						iVdP += iInm*Ud[idP + 1*offset];
					}

          // apply boundary conditions
          // int bc = EToB[face+p_Nfaces*e];

          // if(bc>0){
          //   insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
          // }


					// Find max normal velocity on the face
					dfloat unm   = fabs(nx*iUM + ny*iVM);
					dfloat unp   = fabs(nx*iUP + ny*iVP);    
					dfloat unmax = (unm > unp) ? unm : unp;

					// evaluate "flux" terms: LLF
					dfloat sc = invJ * sJ ;

					s_iFluxU[n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
					+ny*(iVP*iUdP + iVM*iUdM) 
					+unmax*(iUdM-iUdP) ));

					s_iFluxV[n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
					+ ny*(iVP*iVdP + iVM*iVdM) 
					+ unmax*(iVdM-iVdP) ));
        }
      }
    }

    @barrier("local");

    // lift from surface integration to volume nodes
    for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
      if(e<Nelements){
        if(n<p_Np){
          int id = n + p_Np*e;
          // prefetch volume rhs
          dfloat rhsu = rhsU[id + 0*offset];
          dfloat rhsv = rhsU[id + 1*offset];
          //
          for(int m=0;m<p_intNfpNfaces;++m){
            dfloat L = intLIFTT[n+m*p_Np];
            rhsu += L*s_iFluxU[m];
            rhsv += L*s_iFluxV[m];
          }
          rhsU[id + 0*offset] = rhsu;  // 
          rhsU[id + 1*offset] = rhsv;  //  
        }
      }
    }
  }
}




@kernel void insSubCycleCubatureSurfaceTri2D_v1(dlong Nelements,
                                            dfloat *  vgeo,
                                            dfloat *  sgeo,
                                            dfloat *  cubsgeo,
                                            dfloat *  intInterpT, // interpolate to integration nodes
                                            dfloat *  intLIFTT, // lift from integration to interpolation nodes
                                            dfloat *  cubInterpT,
                                            dfloat *  cubProjectT,
                                            dlong  *  vmapM,
                                            dlong  *  vmapP,
																						int    *  EToB,
																						dfloat bScale,
																						dfloat time,
                                            dfloat *  intx, // integration nodes
                                            dfloat *  inty,
                                            dfloat *  intz,
                                            dlong     offset,
                                            dfloat *  U,
                                            dfloat *  Ud,
                                            dfloat *  rhsU){
  // for all elements
  for(dlong e=0;e<Nelements;++e;@outer(0)){

    // @shared storage for flux terms
    @shared dfloat s_UM[p_NfacesNfp];
    @shared dfloat s_VM[p_NfacesNfp];
    @shared dfloat s_UP[p_NfacesNfp];
    @shared dfloat s_VP[p_NfacesNfp];

    @shared dfloat s_UdM[p_NfacesNfp];
    @shared dfloat s_VdM[p_NfacesNfp];
    @shared dfloat s_UdP[p_NfacesNfp];
    @shared dfloat s_VdP[p_NfacesNfp];

    @shared dfloat s_iFluxU[p_intNfpNfaces];
    @shared dfloat s_iFluxV[p_intNfpNfaces];


    for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
      if(e<Nelements){
        if(n<(p_Nfaces*p_Nfp)){
          // indices of negative and positive traces of face node
          dlong id  = e*p_Nfp*p_Nfaces + n;
          dlong idM = vmapM[id];
          dlong idP = vmapP[id];

          if(idP<0) idP = idM;
					// load negative and positive trace node values of velocity
					s_UM[n] = U[idM + 0*offset];
					s_VM[n] = U[idM + 1*offset];
					s_UP[n] = U[idP + 0*offset];
					s_VP[n] = U[idP + 1*offset];

					s_UdM[n] = Ud[idM + 0*offset];
					s_VdM[n] = Ud[idM + 1*offset];
					s_UdP[n] = Ud[idP + 0*offset];
					s_VdP[n] = Ud[idP + 1*offset];

				}
      }
    }

    @barrier("local");

  
    for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 

      if(e<Nelements){
				if(n<(p_Nfaces*p_intNfp)){

				  int face = n/p_intNfp; // find face that owns this integration node

				  // load surface geofactors for this face
				  dlong sid    = p_Nsgeo*(e*p_Nfaces+face);
				  dfloat nx   = sgeo[sid+p_NXID];
				  dfloat ny   = sgeo[sid+p_NYID];
				  dfloat sJ   = sgeo[sid+p_SJID];
				  dfloat invJ = sgeo[sid+p_IJID];

				  dfloat iUM  = 0.f, iVM  = 0.f;
				  dfloat iUP  = 0.f, iVP  = 0.f;
				  dfloat iUdM = 0.f, iVdM = 0.f;
				  dfloat iUdP = 0.f, iVdP = 0.f;

				  // local block interpolation (face nodes to integration nodes)
				  for(int m=0;m<p_Nfp;++m){
				    dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
				    int fm = face*p_Nfp+m;

				    iUM  += iInm*s_UM[fm];
				    iVM  += iInm*s_VM[fm];
				    iUdM += iInm*s_UdM[fm];
				    iVdM += iInm*s_VdM[fm];

				    iUP  += iInm*s_UP[fm];
				    iVP  += iInm*s_VP[fm];
				    iUdP += iInm*s_UdP[fm];
				    iVdP += iInm*s_VdP[fm];
				  }

				  // // apply boundary conditions
				  // int bc = EToB[face+p_Nfaces*e];

				  // if(bc>0){
				  //   insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
				  // }


 					 // Find max normal velocity on the face
					dfloat unm   = fabs(nx*iUM + ny*iVM);
					dfloat unp   = fabs(nx*iUP + ny*iVP);    
					dfloat unmax = (unm > unp) ? unm : unp;

					// evaluate "flux" terms: LLF
					dfloat sc = invJ * sJ ;

					s_iFluxU[n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
																+ny*(iVP*iUdP + iVM*iUdM) 
																+unmax*(iUdM-iUdP) ));

					s_iFluxV[n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
															 + ny*(iVP*iVdP + iVM*iVdM) 
															 + unmax*(iVdM-iVdP) ));
				}
      }
    }

    @barrier("local");

    // lift from surface integration to volume nodes
    for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
      if(e<Nelements){
				if(n<p_Np){
				  dlong id = n + p_Np*e;
				  // prefetch volume rhs
          dfloat rhsu = rhsU[id + 0*offset];
          dfloat rhsv = rhsU[id + 1*offset];

				  for(int m=0;m<p_intNfpNfaces;++m){
				    dfloat L = intLIFTT[n+m*p_Np];
				    rhsu += L*s_iFluxU[m];
				    rhsv += L*s_iFluxV[m];
				  }

				  rhsU[id + 0*offset] = rhsu;  // 
				  rhsU[id + 1*offset] = rhsv;  //  
				}
      }
    }
  }
}



// Add const and loop unrolling
@kernel void insSubCycleCubatureSurfaceTri2D_v2(          const dlong     Nelements,
			                                          @restrict const dfloat *  vgeo,
			                                          @restrict const dfloat *  sgeo,
			                                          @restrict const dfloat *  cubsgeo,
			                                          @restrict const dfloat *  intInterpT, // interpolate to integration nodes
			                                          @restrict const dfloat *  intLIFTT, // lift from integration to interpolation nodes
			                                          @restrict const dfloat *  cubInterpT,
			                                          @restrict const dfloat *  cubProjectT,
			                                          @restrict const dlong  *  vmapM,
			                                          @restrict const dlong  *  vmapP,
																								@restrict const int    *  EToB,
																													const dfloat bScale,
																													const dfloat time,
			                                          @restrict const dfloat *  intx, // integration nodes
			                                          @restrict const dfloat *  inty,
			                                          @restrict const dfloat *  intz,
			                                                    const dlong     offset,
			                                          @restrict const dfloat *  U,
			                                          @restrict const dfloat *  Ud,
			                                          @restrict       dfloat *  rhsU){
  // for all elements
  for(dlong e=0;e<Nelements;++e;@outer(0)){
    // @shared storage for flux terms
    @shared dfloat s_UM[p_NfacesNfp];
    @shared dfloat s_VM[p_NfacesNfp];
    @shared dfloat s_UP[p_NfacesNfp];
    @shared dfloat s_VP[p_NfacesNfp];

    @shared dfloat s_UdM[p_NfacesNfp];
    @shared dfloat s_VdM[p_NfacesNfp];
    @shared dfloat s_UdP[p_NfacesNfp];
    @shared dfloat s_VdP[p_NfacesNfp];

    @shared dfloat s_iFluxU[p_intNfpNfaces];
    @shared dfloat s_iFluxV[p_intNfpNfaces];

    //
    for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
      if(e<Nelements){
        if(n<(p_Nfaces*p_Nfp)){
					// indices of negative and positive traces of face node
					const dlong id  = e*p_Nfp*p_Nfaces + n;
					const dlong idM = vmapM[id];
					      dlong idP = vmapP[id];

          if(idP<0) idP = idM;
						// load negative and positive trace node values of velocity
						s_UM[n] = U[idM + 0*offset];
						s_VM[n] = U[idM + 1*offset];
						s_UP[n] = U[idP + 0*offset];
						s_VP[n] = U[idP + 1*offset];

						s_UdM[n] = Ud[idM + 0*offset];
						s_VdM[n] = Ud[idM + 1*offset];
						s_UdP[n] = Ud[idP + 0*offset];
						s_VdP[n] = Ud[idP + 1*offset];
				}
      }
    }

    @barrier("local");

  
    for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
      if(e<Nelements){
				if(n<(p_Nfaces*p_intNfp)){

				const int face = n/p_intNfp; // find face that owns this integration node

				// load surface geofactors for this face
				const dlong sid    = p_Nsgeo*(e*p_Nfaces+face);
				const dfloat nx   = sgeo[sid+p_NXID];
				const dfloat ny   = sgeo[sid+p_NYID];
				const dfloat sJ   = sgeo[sid+p_SJID];
				const dfloat invJ = sgeo[sid+p_IJID];

				dfloat iUM  = 0.f, iVM  = 0.f;
				dfloat iUP  = 0.f, iVP  = 0.f;
				dfloat iUdM = 0.f, iVdM = 0.f;
				dfloat iUdP = 0.f, iVdP = 0.f;

				// local block interpolation (face nodes to integration nodes)
				#pragma unroll p_Nfp
				for(int m=0;m<p_Nfp;++m){
					const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
					const int fm = face*p_Nfp+m;

					iUM  += iInm*s_UM[fm];
					iVM  += iInm*s_VM[fm];
					iUdM += iInm*s_UdM[fm];
					iVdM += iInm*s_VdM[fm];

					iUP  += iInm*s_UP[fm];
					iVP  += iInm*s_VP[fm];
					iUdP += iInm*s_UdP[fm];
					iVdP += iInm*s_VdP[fm];
				}

	  // // apply boundary conditions
	  // const int bc = EToB[face+p_Nfaces*e];

	  // if(bc>0){
	  //   insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
	  // }


			// Find max normal velocity on the face
			const dfloat unm   = fabs(nx*iUM + ny*iVM);
			const dfloat unp   = fabs(nx*iUP + ny*iVP);    
			const dfloat unmax = (unm > unp) ? unm : unp;

			// evaluate "flux" terms: LLF
			const dfloat sc = invJ * sJ ;

			s_iFluxU[n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
														+ny*(iVP*iUdP + iVM*iUdM) 
														+unmax*(iUdM-iUdP) ));

			s_iFluxV[n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
													+ ny*(iVP*iVdP + iVM*iVdM) 
													+ unmax*(iVdM-iVdP) ));
				}
      }
    }

    @barrier("local");

    // lift from surface integration to volume nodes
    for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
      if(e<Nelements){
				if(n<p_Np){
				  const dlong id = n + p_Np*e;
				  // prefetch volume rhs
				  dfloat rhsu = 0.f;
				  dfloat rhsv = 0.f;

				  #pragma unroll p_intNfpNfaces
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];
            rhsu += L*s_iFluxU[m];
            rhsv += L*s_iFluxV[m];
          }

				  rhsU[id + 0*offset] += rhsu;  // 
				  rhsU[id + 1*offset] += rhsv;  //  
				}
      }
    }
  }
}






// Optimized sizes for kernel 3
#if p_N==1
#define p_cubNblockS 14
#endif

#if p_N==2
#define p_cubNblockS 8
#endif

#if p_N==3
#define p_cubNblockS 7
#endif

#if p_N==4
#define p_cubNblockS 6
#endif

#if p_N==5
#define p_cubNblockS 6
#endif

#if p_N==6
#define p_cubNblockS 7
#endif

#if p_N==7
#define p_cubNblockS 7
#endif

#if p_N==8
#define p_cubNblockS 6
#endif

#if p_N==9
#define p_cubNblockS 4
#endif

#if p_N==10
#define p_cubNblockS 5
#endif





// Add const and loop unrolling
@kernel void insSubCycleCubatureSurfaceTri2D_v3(          const dlong     Nelements,
			                                          @restrict const dfloat *  vgeo,
			                                          @restrict const dfloat *  sgeo,
			                                          @restrict const dfloat *  cubsgeo,
			                                          @restrict const dfloat *  intInterpT, // interpolate to integration nodes
			                                          @restrict const dfloat *  intLIFTT, // lift from integration to interpolation nodes
			                                          @restrict const dfloat *  cubInterpT,
			                                          @restrict const dfloat *  cubProjectT,
			                                          @restrict const dlong  *  vmapM,
			                                          @restrict const dlong  *  vmapP,
																								@restrict const int    *  EToB,
																													const dfloat bScale,
																													const dfloat time,
			                                          @restrict const dfloat *  intx, // integration nodes
			                                          @restrict const dfloat *  inty,
			                                          @restrict const dfloat *  intz,
			                                                    const dlong     offset,
			                                          @restrict const dfloat *  U,
			                                          @restrict const dfloat *  Ud,
			                                          @restrict       dfloat *  rhsU){
  // for all elements
  for(int eo=0;eo<Nelements;eo+=p_cubNblockS;@outer(0)){

    // @shared storage for flux terms
    @shared dfloat s_UM[p_cubNblockS][p_NfacesNfp];
    @shared dfloat s_VM[p_cubNblockS][p_NfacesNfp];
    @shared dfloat s_UP[p_cubNblockS][p_NfacesNfp];
    @shared dfloat s_VP[p_cubNblockS][p_NfacesNfp];

    @shared dfloat s_UdM[p_cubNblockS][p_NfacesNfp];
    @shared dfloat s_VdM[p_cubNblockS][p_NfacesNfp];
    @shared dfloat s_UdP[p_cubNblockS][p_NfacesNfp];
    @shared dfloat s_VdP[p_cubNblockS][p_NfacesNfp];

    @shared dfloat s_iFluxU[p_cubNblockS][p_intNfpNfaces];
    @shared dfloat s_iFluxV[p_cubNblockS][p_intNfpNfaces];

    // for all face nodes of all elements
    for(int es=0;es<p_cubNblockS;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){

			dlong e = eo + es;

			if(e<Nelements){
			  if(n<(p_Nfaces*p_Nfp)){
			    // indices of negative and positive traces of face node
			    const dlong id  = e*p_Nfp*p_Nfaces + n;

			    dlong idM = vmapM[id];
			    dlong idP = vmapP[id];

			    if(idP<0) idP = idM;
					// load negative and positive trace node values of velocity
					s_UM[es][n] = U[idM + 0*offset];
					s_VM[es][n] = U[idM + 1*offset];
					s_UP[es][n] = U[idP + 0*offset];
					s_VP[es][n] = U[idP + 1*offset];

					s_UdM[es][n] = Ud[idM + 0*offset];
					s_VdM[es][n] = Ud[idM + 1*offset];
					s_UdP[es][n] = Ud[idP + 0*offset];
					s_VdP[es][n] = Ud[idP + 1*offset];

	  			}
				}
      }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_cubNblockS;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 

			dlong e = eo + es;

			if(e<Nelements){
			  if(n<(p_Nfaces*p_intNfp)){

			    const int face = n/p_intNfp; // find face that owns this integration node

			    // load surface geofactors for this face
			    const dlong sid    = p_Nsgeo*(e*p_Nfaces+face);
			    const dfloat nx   = sgeo[sid+p_NXID];
			    const dfloat ny   = sgeo[sid+p_NYID];
			    const dfloat sJ   = sgeo[sid+p_SJID];
			    const dfloat invJ = sgeo[sid+p_IJID];

			    dfloat iUM  = 0.f, iVM  = 0.f;
			    dfloat iUP  = 0.f, iVP  = 0.f;
			    dfloat iUdM = 0.f, iVdM = 0.f;
			    dfloat iUdP = 0.f, iVdP = 0.f;

			    // local block interpolation (face nodes to integration nodes)
			    #pragma unroll p_Nfp
		      for(int m=0;m<p_Nfp;++m){
						const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
						const int fm = face*p_Nfp+m;

						iUM  += iInm*s_UM[es][fm];
						iVM  += iInm*s_VM[es][fm];
						iUdM += iInm*s_UdM[es][fm];
						iVdM += iInm*s_VdM[es][fm];

						iUP  += iInm*s_UP[es][fm];
						iVP  += iInm*s_VP[es][fm];
						iUdP += iInm*s_UdP[es][fm];
						iVdP += iInm*s_VdP[es][fm];
		      }

	    // // apply boundary conditions
	    // int bc = EToB[face+p_Nfaces*e];

	    // if(bc>0){
	    //   insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, iUdM,iVdM, &iUdP, &iVdP);
	    // }


	    // Find max normal velocity on the face
				dfloat unm   = fabs(nx*iUM + ny*iVM);
				dfloat unp   = fabs(nx*iUP + ny*iVP);    
				dfloat unmax = (unm > unp) ? unm : unp;

				// evaluate "flux" terms: LLF
				const dfloat sc = invJ * sJ ;

				s_iFluxU[es][n] = sc*(.5f*(nx*(iUP*iUdP + iUM*iUdM) 
														       +ny*(iVP*iUdP + iVM*iUdM) 
														       +unmax*(iUdM-iUdP) ));

				s_iFluxV[es][n] = sc*(.5f*(nx*(iUP*iVdP + iUM*iVdM) 
													       + ny*(iVP*iVdP + iVM*iVdM) 
													       + unmax*(iVdM-iVdP) ));
	  		}
				}
      }
    }

    @barrier("local");

    // lift from surface integration to volume nodes
    for(int es=0;es<p_cubNblockS;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        dlong e = eo + es;
        if(e<Nelements){
          if(n<p_Np){
            dlong id = n + p_Np*e;
            // prefetch volume rhs
            dfloat rhsu = 0.f;
            dfloat rhsv = 0.f;

            #pragma unroll p_intNfpNfaces
						for(int m=0;m<p_intNfpNfaces;++m){
							const dfloat L = intLIFTT[n+m*p_Np];
							rhsu += L*s_iFluxU[es][m];
							rhsv += L*s_iFluxV[es][m];
						}

            rhsU[id + 0*offset] += rhsu;  // 
            rhsU[id + 1*offset] += rhsv;  //  
          }
        }
      }
    }
  }

}


// Optimized sizes for kernel 5
#if p_N==1
#define p_NblockS2 10
#define p_NnodesS2 2
#endif

#if p_N==2
#define p_NblockS2 8
#define p_NnodesS2 1
#endif

#if p_N==3
#define p_NblockS2 4
#define p_NnodesS2 2
#endif

#if p_N==4
#define p_NblockS2 3
#define p_NnodesS2 2
#endif

#if p_N==5
#define p_NblockS2 7
#define p_NnodesS2 2
#endif

#if p_N==6
#define p_NblockS2 2
#define p_NnodesS2 2
#endif

#if p_N==7
#define p_NblockS2 3
#define p_NnodesS2 2
#endif

#if p_N==8
#define p_NblockS2 2
#define p_NnodesS2 3
#endif

#if p_N==9
#define p_NblockS2 2
#define p_NnodesS2 3
#endif

#if p_N==10
#define p_NblockS2 3
#define p_NnodesS2 3
#endif



// Add multiple nodes to kernel 3

// Add const and loop unrolling
@kernel void insSubCycleCubatureSurfaceTri2D_v4(          const dlong     Nelements,
			                                          @restrict const dfloat *  vgeo,
			                                          @restrict const dfloat *  sgeo,
			                                          @restrict const dfloat *  cubsgeo,
			                                          @restrict const dfloat *  intInterpT, // interpolate to integration nodes
			                                          @restrict const dfloat *  intLIFTT, // lift from integration to interpolation nodes
			                                          @restrict const dfloat *  cubInterpT,
			                                          @restrict const dfloat *  cubProjectT,
			                                          @restrict const dlong  *  vmapM,
			                                          @restrict const dlong  *  vmapP,
																								@restrict const int    *  EToB,
																													const dfloat bScale,
																													const dfloat time,
			                                          @restrict const dfloat *  intx, // integration nodes
			                                          @restrict const dfloat *  inty,
			                                          @restrict const dfloat *  intz,
			                                                    const dlong     offset,
			                                          @restrict const dfloat *  U,
			                                          @restrict const dfloat *  Ud,
			                                          @restrict       dfloat *  rhsU){
  // for all elements
  for(dlong eo=0;eo<Nelements;eo+=(p_NblockS2*p_NnodesS2);@outer(0)){

    // @shared storage for flux terms
    @shared dfloat s_UM[p_NnodesS2][p_NblockS2][p_intNfpNfaces];
    @shared dfloat s_VM[p_NnodesS2][p_NblockS2][p_intNfpNfaces];
    @shared dfloat s_UP[p_NnodesS2][p_NblockS2][p_NfacesNfp];
    @shared dfloat s_VP[p_NnodesS2][p_NblockS2][p_NfacesNfp];

    @shared dfloat s_UdM[p_NnodesS2][p_NblockS2][p_NfacesNfp];
    @shared dfloat s_VdM[p_NnodesS2][p_NblockS2][p_NfacesNfp];
    @shared dfloat s_UdP[p_NnodesS2][p_NblockS2][p_NfacesNfp];
    @shared dfloat s_VdP[p_NnodesS2][p_NblockS2][p_NfacesNfp];

    #define s_iFluxU s_UM // Reuse @shared memory arrays
    #define s_iFluxV s_VM
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS2;++es;@inner(1)){		
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){

				#pragma unroll p_NnodesS2
				for(int em=0;em<p_NnodesS2;++em){ 
				        
					const dlong e   = eo + es*p_NnodesS2 + em; 
					const dlong id  = e*p_NfacesNfp + n;

					if(e<Nelements && n<p_NfacesNfp ){
						dlong idM = vmapM[id];
						dlong idP = vmapP[id];

						if(idP<0) idP = idM;

						// //load negative and positive trace node values of velocity
						s_UM[em][es][n] = U[idM + 0*offset];
						s_VM[em][es][n] = U[idM + 1*offset];
						s_UP[em][es][n] = U[idP + 0*offset];
						s_VP[em][es][n] = U[idP + 1*offset];

						s_UdM[em][es][n] = Ud[idM + 0*offset];
						s_VdM[em][es][n] = Ud[idM + 1*offset];
						s_UdP[em][es][n] = Ud[idP + 0*offset];
						s_VdP[em][es][n] = Ud[idP + 1*offset];
			 		}	 
     		}
  		}
		}


    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS2;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){

					dfloat cUM[p_NnodesS2], cVM[p_NnodesS2], cUdM[p_NnodesS2], cVdM[p_NnodesS2];
					dfloat cUP[p_NnodesS2], cVP[p_NnodesS2], cUdP[p_NnodesS2], cVdP[p_NnodesS2];
					const int face = n/p_intNfp;       
					   
					#pragma unroll p_NnodesS2
					for(int em=0;em<p_NnodesS2;++em){
					  cUM [em] = 0.f;
					  cVM [em] = 0.f;
					  cUdM[em] = 0.f; 
					  cVdM[em] = 0.f;
					  //
					  cUP [em] = 0.f;
					  cVP [em] = 0.f;
					  cUdP[em] = 0.f; 
					  cVdP[em] = 0.f;
					}

		     // local block interpolation (face nodes to integration nodes)
		    #pragma unroll p_Nfp
		    for(int m=0;m<p_Nfp;++m){
		      const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
		      const int fm = face*p_Nfp + m;
		      #pragma unroll p_NnodesS2
		  		for(int em=0;em<p_NnodesS2;++em){

			      cUM [em] += iInm*s_UM[em][es][fm];
			      cVM [em] += iInm*s_VM[em][es][fm];
			      cUdM[em] += iInm*s_UdM[em][es][fm];
			      cVdM[em] += iInm*s_VdM[em][es][fm];

			      cUP[em]  += iInm*s_UP[em][es][fm];
			      cVP[em]  += iInm*s_VP[em][es][fm];
			      cUdP[em] += iInm*s_UdP[em][es][fm];
			      cVdP[em] += iInm*s_VdP[em][es][fm];
		  		}
		    }

	    #pragma unroll p_NnodesS2
      for(int em=0;em<p_NnodesS2;++em){
        const dlong e = eo + es*p_NnodesS2 + em;
		    const dlong sid    = p_Nsgeo*(e*p_Nfaces+face);
		    const dfloat nx   = sgeo[sid+p_NXID];
		    const dfloat ny   = sgeo[sid+p_NYID];
		    const dfloat sJ   = sgeo[sid+p_SJID];
		    const dfloat invJ = sgeo[sid+p_IJID];
        
		// apply boundary conditions
		// const int bc = EToB[face+p_Nfaces*e];
		// if(bc>0){
		// 	insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM[em],r_iVdM[em], &(r_iUdP[em]), &(r_iVdP[em]));
		// }
        
        
				const dfloat sc = sJ*invJ; 
				//Find max normal velocity on the face
				const dfloat unm   = fabs(nx*cUM[em] + ny*cVM[em]);
				const dfloat unp   = fabs(nx*cUP[em] + ny*cVP[em]);    
				const dfloat unmax = (unm > unp) ? unm : unp;

				s_iFluxU[em][es][n] = sc*(.5f*(nx*(cUP[em]*cUdP[em] + cUM[em]*cUdM[em]) 
				       +ny*(cVP[em]*cUdP[em] + cVM[em]*cUdM[em]) 
				       +unmax*(cUdM[em]- cUdP[em]) ));

				s_iFluxV[em][es][n] = sc*(.5f*(nx*(cUP[em]*cVdP[em] + cUM[em]*cVdM[em]) 
				       +ny*(cVP[em]*cVdP[em] + cVM[em]*cVdM[em]) 
				       +unmax*(cVdM[em]-cVdP[em]) ));
     	 }
  		}
    }
  }

    @barrier("local");

    // lift from surface integration to volume nodes
    for(int es=0;es<p_NblockS2;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
				dfloat rhsu[p_NnodesS2], rhsv[p_NnodesS2];

				if(n<p_Np){
					#pragma unroll p_NnodesS2
					for(int em=0;em<p_NnodesS2;++em){
						rhsu[em] = 0.f;
						rhsv[em] = 0.f;
					}
				//
				#pragma unroll p_intNfpNfaces
				for(int m=0;m<p_intNfpNfaces;++m){
					const dfloat L = intLIFTT[n+m*p_Np];
					#pragma unroll p_NnodesS2
					for(int em=0;em<p_NnodesS2;++em){
						rhsu[em] += L*s_iFluxU[em][es][m];
						rhsv[em] += L*s_iFluxV[em][es][m];
					}
				}

				#pragma unroll p_NnodesS2
				for(int em=0;em<p_NnodesS2;++em){
				dlong e = eo+es*p_NnodesS2+em;
				if(e<Nelements){
					const dlong id = e*p_Np+n;
					rhsU[id + 0*offset]   += rhsu[em]; // note  change in sign
					rhsU[id + 1*offset]   += rhsv[em];    

        }
      }
  		}
      }
    }
     
  #undef s_iFluxU
  #undef s_iFluxV 

  }

}



// Optimized sizes for kernel 5
#if p_N==1
#define p_NblockS5 14
#define p_NnodesS5 2
#endif

#if p_N==2
#define p_NblockS5 8
#define p_NnodesS5 2
#endif

#if p_N==3
#define p_NblockS5 7
#define p_NnodesS5 2
#endif

#if p_N==4
#define p_NblockS5 3
#define p_NnodesS5 2
#endif

#if p_N==5
#define p_NblockS5 7
#define p_NnodesS5 2
#endif

#if p_N==6
#define p_NblockS5 5
#define p_NnodesS5 2
#endif

#if p_N==7
#define p_NblockS5 7
#define p_NnodesS5 2
#endif

#if p_N==8
#define p_NblockS5 4
#define p_NnodesS5 3
#endif

#if p_N==9
#define p_NblockS5 2
#define p_NnodesS5 3
#endif

#if p_N==10
#define p_NblockS5 2
#define p_NnodesS5 4
#endif



// // Multiple nodes per thread// use less @shared memory by factor 2 
// Add const and loop unrolling
@kernel void insSubCycleCubatureSurfaceTri2D_v5(          const dlong     Nelements,
			                                          @restrict const dfloat *  vgeo,
			                                          @restrict const dfloat *  sgeo,
			                                          @restrict const dfloat *  cubsgeo,
			                                          @restrict const dfloat *  intInterpT, // interpolate to integration nodes
			                                          @restrict const dfloat *  intLIFTT, // lift from integration to interpolation nodes
			                                          @restrict const dfloat *  cubInterpT,
			                                          @restrict const dfloat *  cubProjectT,
			                                          @restrict const dlong  *  vmapM,
			                                          @restrict const dlong  *  vmapP,
																								@restrict const int    *  EToB,
																													const dfloat bScale,
																													const dfloat time,
			                                          @restrict const dfloat *  intx, // integration nodes
			                                          @restrict const dfloat *  inty,
			                                          @restrict const dfloat *  intz,
			                                                    const dlong     offset,
			                                          @restrict const dfloat *  U,
			                                          @restrict const dfloat *  Ud,
			                                          @restrict       dfloat *  rhsU){
  // for all elements
  for(dlong eo=0;eo<Nelements;eo+=(p_NblockS5*p_NnodesS5);@outer(0)){

    // @shared storage 
    @shared dfloat s_UM[p_NnodesS5][p_NblockS5][p_intNfpNfaces];
    @shared dfloat s_VM[p_NnodesS5][p_NblockS5][p_intNfpNfaces];
    @shared dfloat s_UP[p_NnodesS5][p_NblockS5][p_intNfpNfaces];
    @shared dfloat s_VP[p_NnodesS5][p_NblockS5][p_intNfpNfaces];
   
    #define s_iFluxU s_UM // Reuse @shared memory arrays
    #define s_iFluxV s_VM

    @exclusive dfloat r_iUM[p_NnodesS5],  r_iUP[p_NnodesS5];
    @exclusive dfloat r_iVM[p_NnodesS5],  r_iVP[p_NnodesS5];
    @exclusive dfloat r_iUdM[p_NnodesS5], r_iUdP[p_NnodesS5];
    @exclusive dfloat r_iVdM[p_NnodesS5], r_iVdP[p_NnodesS5];

     @exclusive dlong idM[p_NnodesS5], idP[p_NnodesS5];
     @exclusive int face;

    // Loop for minus traces
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS5;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<(p_Nfaces*p_Nfp)){
          #pragma unroll p_NnodesS5
          for (int em=0;em<p_NnodesS5;++em){
            const dlong e = em*p_NblockS5 + es + eo;
            if (e<Nelements) {
              // indices of negative and positive traces of face node
              const dlong id  = e*p_Nfp*p_Nfaces + n;
              idM[em] = vmapM[id];
              idP[em] = vmapP[id];

              // load negative and positive trace node values of velocity
              s_UM[em][es][n] = U[idM[em] + 0*offset];
              s_UP[em][es][n] = U[idP[em] + 0*offset];  
              s_VM[em][es][n] = U[idM[em] + 1*offset];
              s_VP[em][es][n] = U[idP[em] + 1*offset];              
            }
          }
        }
      }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS5;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
          face = n/p_intNfp; // find face that owns this integration node

          #pragma unroll p_NnodesS5
          for (int em=0;em<p_NnodesS5;++em){
            r_iUM[em]  = 0.f;
            r_iUP[em]  = 0.f;
            r_iVM[em]  = 0.f;
            r_iVP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            #pragma unroll p_NnodesS5
            for (int em=0;em<p_NnodesS5;++em){
              r_iUM[em]  += iInm*s_UM[em][es][fm];
              r_iUP[em]  += iInm*s_UP[em][es][fm];
              r_iVM[em]  += iInm*s_VM[em][es][fm];
              r_iVP[em]  += iInm*s_VP[em][es][fm];
            }
          }
        }
      }
    }
    @barrier("local");

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS5;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<(p_Nfaces*p_Nfp)){
          #pragma unroll p_NnodesS5
          for (int em=0;em<p_NnodesS5;++em){
            const dlong e = em*p_NblockS5 + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of advection field
              s_UM[em][es][n] = Ud[idM[em] + 0*offset];
              s_UP[em][es][n] = Ud[idP[em] + 0*offset]; 
              s_VM[em][es][n] = Ud[idM[em] + 1*offset];
              s_VP[em][es][n] = Ud[idP[em] + 1*offset];                     
            }
          }
        }
      }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS5;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
          #pragma unroll p_NnodesS5
          for (int em=0;em<p_NnodesS5;++em){
            r_iUdM[em]  = 0.f;
            r_iUdP[em]  = 0.f;
            r_iVdM[em]  = 0.f;
            r_iVdP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            #pragma unroll p_NnodesS5
            for (int em=0;em<p_NnodesS5;++em){
              r_iUdM[em] += iInm*s_UM[em][es][fm];
              r_iUdP[em] += iInm*s_UP[em][es][fm];
              r_iVdM[em] += iInm*s_VM[em][es][fm];
              r_iVdP[em] += iInm*s_VP[em][es][fm];
            }
          }
        }
      }
    }
    @barrier("local");

    // Use traces to compuite and store flux
    for(int es=0;es<p_NblockS5;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        #pragma unroll p_NnodesS5
        for (int em=0;em<p_NnodesS5;++em){
          const dlong e = em*p_NblockS5 + es + eo;
          if((e<Nelements)&&(n<(p_Nfaces*p_intNfp))){
            // load surface geofactors for this face
            const dlong sid    = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            // // apply boundary conditions
            // const int bc = EToB[face+p_Nfaces*e];
            // if(bc>0){
            //   insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM[em],r_iVdM[em], &(r_iUdP[em]), &(r_iVdP[em]));
            // }

            // Find max normal velocity on the face
            const dfloat unm   = fabs(nx*r_iUM[em] + ny*r_iVM[em]);
            const dfloat unp   = fabs(nx*r_iUP[em] + ny*r_iVP[em]);    
            const dfloat unmax = (unm > unp) ? unm : unp;

            // evaluate "flux" terms: LLF
            const dfloat sc = 0.5f*invJ*sJ;

            // bad notation here //
            s_iFluxU[em][es][n] = sc*(nx*(r_iUP[em]*r_iUdP[em] + r_iUM[em]*r_iUdM[em]) 
                                +ny*(r_iVP[em]*r_iUdP[em] + r_iVM[em]*r_iUdM[em]) 
                                +unmax*(r_iUdM[em]-r_iUdP[em]));

            s_iFluxV[em][es][n] = sc*(nx*(r_iUP[em]*r_iVdP[em] + r_iUM[em]*r_iVdM[em]) 
                               + ny*(r_iVP[em]*r_iVdP[em] + r_iVM[em]*r_iVdM[em]) 
                               + unmax*(r_iVdM[em]-r_iVdP[em]));
          }
        }
      }
    }

    @barrier("local");

    // lift from surface integration to volume nodes
    for(int es=0;es<p_NblockS5;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<p_Np){
          #pragma unroll p_NnodesS5
          for (int em=0;em<p_NnodesS5;++em){
            const dlong e = em*p_NblockS5 + es + eo;
            if(e<Nelements) {
              const dlong id = n + p_Np*e;
              // prefemch volume rhs
              // r_iUM[em] = rhsU[id];
              // r_iVM[em] = rhsV[id];
              r_iUM[em] = 0.f;
              r_iVM[em] = 0.f;
            }
          }

          #pragma unroll p_intNfpNfaces
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];

            #pragma unroll p_NnodesS5
            for (int em=0;em<p_NnodesS5;++em){
              r_iUM[em] += L*s_UM[em][es][m];
              r_iVM[em] += L*s_VM[em][es][m];
            }
          }

          #pragma unroll p_NnodesS5
          for (int em=0;em<p_NnodesS5;++em){
            const int e = em*p_NblockS5 + es + eo;
            if(e<Nelements) {
              const dlong id = n + p_Np*e;
              // prefemch volume rhs
              rhsU[id + 0*offset] = r_iUM[em];
              rhsU[id + 1*offset] = r_iVM[em];
            }
          }
        }
      }
    }
  #undef s_iFluxU
  #undef s_iFluxV  
  }
}





// Optimized sizes for kernel 5
#if p_N==1
#define p_NblockS3 10
#define p_NnodesS3 2
#endif

#if p_N==2
#define p_NblockS3 8
#define p_NnodesS3 3
#endif

#if p_N==3
#define p_NblockS3 7
#define p_NnodesS3 5
#endif

#if p_N==4
#define p_NblockS3 6
#define p_NnodesS3 3
#endif

#if p_N==5
#define p_NblockS3 2
#define p_NnodesS3 5
#endif

#if p_N==6
#define p_NblockS3 2
#define p_NnodesS3 5
#endif

#if p_N==7
#define p_NblockS3 3
#define p_NnodesS3 5
#endif

#if p_N==8
#define p_NblockS3 2
#define p_NnodesS3 5
#endif

#if p_N==9
#define p_NblockS3 2
#define p_NnodesS3 4
#endif

#if p_N==10
#define p_NblockS3 2
#define p_NnodesS3 4
#endif

// // Multiple nodes per thread// use less @shared memory by factor 2 
// Add const and loop unrolling
@kernel void insSubCycleCubatureSurfaceTri2D_v6(          const dlong     Nelements,
			                                          @restrict const dfloat *  vgeo,
			                                          @restrict const dfloat *  sgeo,
			                                          @restrict const dfloat *  cubsgeo,
			                                          @restrict const dfloat *  intInterpT, // interpolate to integration nodes
			                                          @restrict const dfloat *  intLIFTT, // lift from integration to interpolation nodes
			                                          @restrict const dfloat *  cubInterpT,
			                                          @restrict const dfloat *  cubProjectT,
			                                          @restrict const dlong  *  vmapM,
			                                          @restrict const dlong  *  vmapP,
																								@restrict const int    *  EToB,
																													const dfloat bScale,
																													const dfloat time,
			                                          @restrict const dfloat *  intx, // integration nodes
			                                          @restrict const dfloat *  inty,
			                                          @restrict const dfloat *  intz,
			                                                    const dlong     offset,
			                                          @restrict const dfloat *  U,
			                                          @restrict const dfloat *  Ud,
			                                          @restrict       dfloat *  rhsU){
  // for all elements
  for(dlong eo=0;eo<Nelements;eo+=(p_NblockS3*p_NnodesS3);@outer(0)){

    // @shared storage 
    @shared dfloat s_U[p_NnodesS3][p_NblockS3][p_intNfpNfaces];
    @shared dfloat s_V[p_NnodesS3][p_NblockS3][p_intNfpNfaces];
   
    #define s_iFluxU s_U // Reuse @shared memory arrays
    #define s_iFluxV s_V

    @exclusive dfloat r_iUM[p_NnodesS3],  r_iUP[p_NnodesS3];
    @exclusive dfloat r_iVM[p_NnodesS3],  r_iVP[p_NnodesS3];
    @exclusive dfloat r_iUdM[p_NnodesS3], r_iUdP[p_NnodesS3];
    @exclusive dfloat r_iVdM[p_NnodesS3], r_iVdP[p_NnodesS3];

    @exclusive dlong idM[p_NnodesS3], idP[p_NnodesS3];
    @exclusive int face;

    // Loop for minus traces
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<(p_Nfaces*p_Nfp)){
          #pragma unroll p_NnodesS3
          for (int em=0;em<p_NnodesS3;++em){
            const dlong e = em*p_NblockS3 + es + eo;
            if (e<Nelements) {
              // indices of negative and positive traces of face node
              const dlong id  = e*p_Nfp*p_Nfaces + n;
              idM[em] = vmapM[id];
              idP[em] = vmapP[id];

              // load negative and positive trace node values of velocity
              s_U[em][es][n] = U[idM[em] + 0*offset];
              s_V[em][es][n] = U[idM[em] + 1*offset];              
            }
          }
        }
      }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
          face = n/p_intNfp; // find face that owns this integration node
          #pragma unroll p_NnodesS3
          for (int em=0;em<p_NnodesS3;++em){
            r_iUM[em]  = 0.f;
            r_iVM[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            #pragma unroll p_NnodesS3
            for (int em=0;em<p_NnodesS3;++em){
              r_iUM[em]  += iInm*s_U[em][es][fm];
              r_iVM[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }


    @barrier("local");

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<(p_Nfaces*p_Nfp)){
          #pragma unroll p_NnodesS3
          for (int em=0;em<p_NnodesS3;++em){
            const dlong e = em*p_NblockS3 + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of advection field
              s_U[em][es][n] = Ud[idM[em] + 0*offset];
              s_V[em][es][n] = Ud[idM[em] + 1*offset];              
            }
          }
        }
      }
    }


    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
          #pragma unroll p_NnodesS3
          for (int em=0;em<p_NnodesS3;++em){
            r_iUdM[em]  = 0.f;
            r_iVdM[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            #pragma unroll p_NnodesS3
            for (int em=0;em<p_NnodesS3;++em){
              r_iUdM[em]  += iInm*s_U[em][es][fm];
              r_iVdM[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    @barrier("local");

      // Loop for positive traces
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<(p_Nfaces*p_Nfp)){
          #pragma unroll p_NnodesS3
          for (int em=0;em<p_NnodesS3;++em){
            const dlong e = em*p_NblockS3 + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of velocity
              s_U[em][es][n] = U[idP[em]];
              s_V[em][es][n] = U[idP[em]];              
            }
          }
        }
      }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
          #pragma unroll p_NnodesS3
          for (int em=0;em<p_NnodesS3;++em){
            r_iUP[em]  = 0.f;
            r_iVP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            #pragma unroll p_NnodesS3
            for (int em=0;em<p_NnodesS3;++em){
              r_iUP[em]  += iInm*s_U[em][es][fm];
              r_iVP[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    @barrier("local");

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<(p_Nfaces*p_Nfp)){
          #pragma unroll p_NnodesS3
          for (int em=0;em<p_NnodesS3;++em){
            const dlong e = em*p_NblockS3 + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of advection field
              s_U[em][es][n] = Ud[idP[em] + 0*offset];
              s_V[em][es][n] = Ud[idP[em] + 1*offset];              
            }
          }
        }
      }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
          #pragma unroll p_NnodesS3
          for (int em=0;em<p_NnodesS3;++em){
            r_iUdP[em]  = 0.f;
            r_iVdP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            #pragma unroll p_NnodesS3
            for (int em=0;em<p_NnodesS3;++em){
              r_iUdP[em]  += iInm*s_U[em][es][fm];
              r_iVdP[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    @barrier("local");

    // Use traces to compuite and store flux
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        #pragma unroll p_NnodesS3
        for (int em=0;em<p_NnodesS3;++em){
          const dlong e = em*p_NblockS3 + es + eo;
          if((e<Nelements)&&(n<(p_Nfaces*p_intNfp))){
            // load surface geofactors for this face
            const dlong sid   = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            // // apply boundary conditions
            // const int bc = EToB[face+p_Nfaces*e];
            // if(bc>0){
            //   insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM[em],r_iVdM[em], &(r_iUdP[em]), &(r_iVdP[em]));
            // }

            // Find max normal velocity on the face
            const dfloat unm   = fabs(nx*r_iUM[em] + ny*r_iVM[em]);
            const dfloat unp   = fabs(nx*r_iUP[em] + ny*r_iVP[em]);    
            const dfloat unmax = (unm > unp) ? unm : unp;

            // evaluate "flux" terms: LLF
            const dfloat sc = 0.5f*invJ*sJ;

            // bad notation here //
            s_iFluxU[em][es][n] = sc*(nx*(r_iUP[em]*r_iUdP[em] + r_iUM[em]*r_iUdM[em]) 
                                +ny*(r_iVP[em]*r_iUdP[em] + r_iVM[em]*r_iUdM[em]) 
                                +unmax*(r_iUdM[em]-r_iUdP[em]));

            s_iFluxV[em][es][n] = sc*(nx*(r_iUP[em]*r_iVdP[em] + r_iUM[em]*r_iVdM[em]) 
                               + ny*(r_iVP[em]*r_iVdP[em] + r_iVM[em]*r_iVdM[em]) 
                               + unmax*(r_iVdM[em]-r_iVdP[em]));
          }
        }
      }
    }

    @barrier("local");

    // lift from surface integration to volume nodes
    for(int es=0;es<p_NblockS3;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<p_Np){
          #pragma unroll p_NnodesS3
          for (int em=0;em<p_NnodesS3;++em){
            const dlong e = em*p_NblockS3 + es + eo;
            if(e<Nelements) {
              const int id = n + p_Np*e;
              // prefemch volume rhs
              // r_iUM[em] = rhsU[id];
              // r_iVM[em] = rhsV[id];
              r_iUM[em] = 0.f;
              r_iVM[em] = 0.f;
            }
          }

          #pragma unroll p_intNfpNfaces
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];

            #pragma unroll p_NnodesS3
            for (int em=0;em<p_NnodesS3;++em){
              r_iUM[em] += L*s_U[em][es][m];
              r_iVM[em] += L*s_V[em][es][m];
            }
          }

          #pragma unroll p_NnodesS3
          for (int em=0;em<p_NnodesS3;++em){
            const int e = em*p_NblockS3 + es + eo;
            if(e<Nelements) {
              const dlong id = n + p_Np*e;
              // prefemch volume rhs
              rhsU[id + 0*offset] = r_iUM[em];
              rhsU[id + 1*offset] = r_iVM[em];
            }
          }
        }
      }
    }
  #undef s_iFluxU
  #undef s_iFluxV  
  }
}














// Optimized sizes for kernel 5
#if p_N==1
#define p_NblockS4 7
#define p_NnodesS4 5
#endif

#if p_N==2
#define p_NblockS4 8
#define p_NnodesS4 3
#endif

#if p_N==3
#define p_NblockS4 7
#define p_NnodesS4 5
#endif

#if p_N==4
#define p_NblockS4 3
#define p_NnodesS4 5
#endif

#if p_N==5
#define p_NblockS4 7
#define p_NnodesS4 5
#endif

#if p_N==6
#define p_NblockS4 2
#define p_NnodesS4 5
#endif

#if p_N==7
#define p_NblockS4 7
#define p_NnodesS4 5
#endif

#if p_N==8
#define p_NblockS4 2
#define p_NnodesS4 5
#endif

#if p_N==9
#define p_NblockS4 1
#define p_NnodesS4 5
#endif

#if p_N==10
#define p_NblockS4 2
#define p_NnodesS4 4
#endif



// // Multiple nodes per thread// use less @shared memory by factor 2 
// Add const and loop unrolling
@kernel void insSubCycleCubatureSurfaceTri2D_v7(          const dlong     Nelements,
			                                          @restrict const dfloat *  vgeo,
			                                          @restrict const dfloat *  sgeo,
			                                          @restrict const dfloat *  cubsgeo,
			                                          @restrict const dfloat *  intInterpT, // interpolate to integration nodes
			                                          @restrict const dfloat *  intLIFTT, // lift from integration to interpolation nodes
			                                          @restrict const dfloat *  cubInterpT,
			                                          @restrict const dfloat *  cubProjectT,
			                                          @restrict const dlong  *  vmapM,
			                                          @restrict const dlong  *  vmapP,
																								@restrict const int    *  EToB,
																													const dfloat bScale,
																													const dfloat time,
			                                          @restrict const dfloat *  intx, // integration nodes
			                                          @restrict const dfloat *  inty,
			                                          @restrict const dfloat *  intz,
			                                                    const dlong     offset,
			                                          @restrict const dfloat *  U,
			                                          @restrict const dfloat *  Ud,
			                                          @restrict       dfloat *  rhsU){
  // for all elements
  for(dlong eo=0;eo<Nelements;eo+=(p_NblockS4*p_NnodesS4);@outer(0)){

    // @shared storage 
    @shared dfloat s_U[p_NnodesS4][p_NblockS4][p_intNfpNfaces];
    @shared dfloat s_V[p_NnodesS4][p_NblockS4][p_intNfpNfaces];
   
    #define s_iFluxU s_U // Reuse @shared memory arrays
    #define s_iFluxV s_V

    @exclusive dfloat r_iUM[p_NnodesS4],  r_iUP[p_NnodesS4];
    @exclusive dfloat r_iVM[p_NnodesS4],  r_iVP[p_NnodesS4];
    @exclusive dfloat r_iUdM[p_NnodesS4], r_iUdP[p_NnodesS4];
    @exclusive dfloat r_iVdM[p_NnodesS4], r_iVdP[p_NnodesS4];

    @exclusive dlong idM[p_NnodesS4], idP[p_NnodesS4];
    @exclusive int face;

    // Loop for minus traces
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<(p_Nfaces*p_Nfp)){
          #pragma unroll p_NnodesS4 
          for (int em=0;em<p_NnodesS4;++em){
            const dlong e = em*p_NblockS4 + es + eo;
            if (e<Nelements) {
              // indices of negative and positive traces of face node
              const dlong id  = e*p_Nfp*p_Nfaces + n;
              idM[em] = vmapM[id];
              idP[em] = vmapP[id];

              // load negative and positive trace node values of velocity
              s_U[em][es][n] = U[idM[em] + 0*offset];
              s_V[em][es][n] = U[idP[em] + 0*offset];              
            }
          }
        }
      }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
          face = n/p_intNfp; // find face that owns this integration node

          #pragma unroll p_NnodesS4 
          for (int em=0;em<p_NnodesS4;++em){
            r_iUM[em]  = 0.f;
            r_iUP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            #pragma unroll p_NnodesS4 
            for (int em=0;em<p_NnodesS4;++em){
              r_iUM[em]  += iInm*s_U[em][es][fm];
              r_iUP[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    @barrier("local");

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<(p_Nfaces*p_Nfp)){
          #pragma unroll p_NnodesS4 
          for (int em=0;em<p_NnodesS4;++em){
            const dlong e = em*p_NblockS4 + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of advection field
              s_U[em][es][n] = Ud[idM[em] +0*offset];
              s_V[em][es][n] = Ud[idP[em] +0*offset];              
            }
          }
        }
      }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
          #pragma unroll p_NnodesS4 
          for (int em=0;em<p_NnodesS4;++em){
            r_iUdM[em]  = 0.f;
            r_iUdP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            #pragma unroll p_NnodesS4 
            for (int em=0;em<p_NnodesS4;++em){
              r_iUdM[em]  += iInm*s_U[em][es][fm];
              r_iUdP[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    @barrier("local");

      // Loop for positive traces
    // for all face nodes of all elements
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<(p_Nfaces*p_Nfp)){
          #pragma unroll p_NnodesS4 
          for (int em=0;em<p_NnodesS4;++em){
            const dlong e = em*p_NblockS4 + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of velocity
              s_U[em][es][n] = U[idM[em] + 1*offset];
              s_V[em][es][n] = U[idP[em] + 1*offset];              
            }
          }
        }
      }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
          #pragma unroll p_NnodesS4 
          for (int em=0;em<p_NnodesS4;++em){
            r_iVM[em]  = 0.f;
            r_iVP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            #pragma unroll p_NnodesS4 
            for (int em=0;em<p_NnodesS4;++em){
              r_iVM[em]  += iInm*s_U[em][es][fm];
              r_iVP[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    @barrier("local");

    // for all face nodes of all elements
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<(p_Nfaces*p_Nfp)){
          #pragma unroll p_NnodesS4 
          for (int em=0;em<p_NnodesS4;++em){
            const dlong e = em*p_NblockS4 + es + eo;
            if (e<Nelements) {
              // load negative and positive trace node values of advection field
              s_U[em][es][n] = Ud[idM[em] + 1*offset];
              s_V[em][es][n] = Ud[idP[em] + 1*offset];              
            }
          }
        }
      }
    }

    @barrier("local");

    // interpolate to surface integration nodes
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        if(n<(p_Nfaces*p_intNfp)){
          #pragma unroll p_NnodesS4 
          for (int em=0;em<p_NnodesS4;++em){
            r_iVdM[em]  = 0.f;
            r_iVdP[em]  = 0.f;
          }

          // local block interpolation (face nodes to integration nodes)
          #pragma unroll p_Nfp
          for(int m=0;m<p_Nfp;++m){
            const dfloat iInm = intInterpT[n+m*p_Nfaces*p_intNfp];
            const int fm = face*p_Nfp+m;

            #pragma unroll p_NnodesS4 
            for (int em=0;em<p_NnodesS4;++em){
              r_iVdM[em]  += iInm*s_U[em][es][fm];
              r_iVdP[em]  += iInm*s_V[em][es][fm];
            }
          }
        }
      }
    }
    @barrier("local");

    // Use traces to compuite and store flux
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){ 
        #pragma unroll p_NnodesS4 
        for (int em=0;em<p_NnodesS4;++em){
          const dlong e = em*p_NblockS4 + es + eo;
          if((e<Nelements)&&(n<(p_Nfaces*p_intNfp))){
            // load surface geofactors for this face
            const dlong sid   = p_Nsgeo*(e*p_Nfaces+face);
            const dfloat nx   = sgeo[sid+p_NXID];
            const dfloat ny   = sgeo[sid+p_NYID];
            const dfloat sJ   = sgeo[sid+p_SJID];
            const dfloat invJ = sgeo[sid+p_IJID];

            // // apply boundary conditions
            // const int bc = EToB[face+p_Nfaces*e];
            // if(bc>0){
            //   insAdvectionBoundaryConditions2D(bc,time, intx[n+e*p_Nfaces*p_intNfp], inty[n+e*p_Nfaces*p_intNfp], nx, ny, r_iUdM[em],r_iVdM[em], &(r_iUdP[em]), &(r_iVdP[em]));
            // }

            // Find max normal velocity on the face
            const dfloat unm   = fabs(nx*r_iUM[em] + ny*r_iVM[em]);
            const dfloat unp   = fabs(nx*r_iUP[em] + ny*r_iVP[em]);    
            const dfloat unmax = (unm > unp) ? unm : unp;

            // evaluate "flux" terms: LLF
            const dfloat sc = 0.5f*invJ*sJ;

            // bad notation here //
            s_iFluxU[em][es][n] = sc*(nx*(r_iUP[em]*r_iUdP[em] + r_iUM[em]*r_iUdM[em]) 
                                +ny*(r_iVP[em]*r_iUdP[em] + r_iVM[em]*r_iUdM[em]) 
                                +unmax*(r_iUdM[em]-r_iUdP[em]));

            s_iFluxV[em][es][n] = sc*(nx*(r_iUP[em]*r_iVdP[em] + r_iUM[em]*r_iVdM[em]) 
                               + ny*(r_iVP[em]*r_iVdP[em] + r_iVM[em]*r_iVdM[em]) 
                               + unmax*(r_iVdM[em]-r_iVdP[em]));
          }
        }
      }
    }

    @barrier("local");

    // lift from surface integration to volume nodes
    for(int es=0;es<p_NblockS4;++es;@inner(1)){
      for(int n=0;n<p_maxNodesSurfaceCub;++n;@inner(0)){
        if(n<p_Np){
          #pragma unroll p_NnodesS4 
          for (int em=0;em<p_NnodesS4;++em){
            const dlong e = em*p_NblockS4 + es + eo;
            if(e<Nelements) {
              const int id = n + p_Np*e;
              // prefemch volume rhs
              // r_iUM[em] = rhsU[id];
              // r_iVM[em] = rhsV[id];
              r_iUM[em] = 0.f;
              r_iVM[em] = 0.f;
            }
          }

          #pragma unroll p_intNfpNfaces
          for(int m=0;m<p_intNfpNfaces;++m){
            const dfloat L = intLIFTT[n+m*p_Np];

            #pragma unroll p_NnodesS4 
            for (int em=0;em<p_NnodesS4;++em){
              r_iUM[em] += L*s_U[em][es][m];
              r_iVM[em] += L*s_V[em][es][m];
            }
          }

          #pragma unroll p_NnodesS4 
          for (int em=0;em<p_NnodesS4;++em){
            const dlong e = em*p_NblockS4 + es + eo;
            if(e<Nelements) {
              const dlong id = n + p_Np*e;
              // prefemch volume rhs
              rhsU[id + 0*offset] = r_iUM[em];
              rhsU[id + 1*offset] = r_iVM[em];
            }
          }
        }
      }
    }
  #undef s_iFluxU
  #undef s_iFluxV  
  }
}

