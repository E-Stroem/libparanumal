
// A very bad gradient kernel, 
@kernel void ellipticPartialGradientTri2D_v0(dlong Nelements,
                                           dlong offset,
                                           dfloat *vgeo,
                                           dfloat *Dmatrices, 
                                           dfloat *q,
                                           dfloat4 *gradq){
  
  for(dlong e=0;e<Nelements;++e;@outer(0)){
    for(int n=0;n<p_Np;++n;@inner(0)){
      dlong element = e+offset; 
      //
      dfloat drdx = vgeo[p_Nvgeo*element+p_RXID];
      dfloat drdy = vgeo[p_Nvgeo*element+p_RYID];
      dfloat dsdx = vgeo[p_Nvgeo*element+p_SXID];
      dfloat dsdy = vgeo[p_Nvgeo*element+p_SYID];

      //
      dfloat qr = 0.f, qs = 0.f;

      for(int i=0;i<p_Np;++i){
        qr += Dmatrices[n + i*p_Np + 0*p_Np*p_Np]*q[i+element*p_Np];
        qs += Dmatrices[n + i*p_Np + 1*p_Np*p_Np]*q[i+element*p_Np];
      }

      dfloat4 gradqn;
      gradqn.x = drdx*qr + dsdx*qs;
      gradqn.y = drdy*qr + dsdy*qs;
      gradqn.w = q[n+element*p_Np];
      
      dlong id = element*p_Np+n; 
      gradq[id] = gradqn;
    }
  }
}



// A very bad gradient kernel, 
@kernel void ellipticPartialGradientTri2D_v1(dlong Nelements,
                                           dlong offset,
                                           dfloat *vgeo,
                                           dfloat *Dmatrices, 
                                           dfloat *q,
                                           dfloat4 *gradq){
  
  for(dlong e=0;e<Nelements;++e;@outer(0)){

    @shared dfloat s_q[p_Np];

     for(int n=0;n<p_Np;++n;@inner(0)){
      dlong id = n + (e+offset)*p_Np;
      s_q[n] = q[id];
    }

    @barrier("local");

    for(int n=0;n<p_Np;++n;@inner(0)){

      dfloat drdx = vgeo[p_Nvgeo*e+p_RXID];
      dfloat drdy = vgeo[p_Nvgeo*e+p_RYID];
      dfloat dsdx = vgeo[p_Nvgeo*e+p_SXID];
      dfloat dsdy = vgeo[p_Nvgeo*e+p_SYID];

      dfloat qr = 0.f, qs = 0.f;

      for(int i=0;i<p_Np;++i){
        qr += Dmatrices[n + i*p_Np + 0*p_Np*p_Np]*s_q[i];
        qs += Dmatrices[n + i*p_Np + 1*p_Np*p_Np]*s_q[i];
      }

      dfloat4 gradqn;
      gradqn.x = drdx*qr + dsdx*qs;
      gradqn.y = drdy*qr + dsdy*qs;
      gradqn.w = s_q[n];
      
      dlong id = (e+offset)*p_Np+n; 
      gradq[id] = gradqn;
    }
  }
}



@kernel void ellipticPartialGradientTri2D_v2(          const dlong Nelements,
                                                       const dlong offset,
                                             @restrict const dfloat *vgeo,
                                             @restrict const dfloat *Dmatrices, 
                                             @restrict const dfloat *q,
                                             @restrict       dfloat4 *gradq){
  
  for(int e=0;e<Nelements;++e;@outer(0)){

    @shared dfloat s_q[p_Np];

     for(int n=0;n<p_Np;++n;@inner(0)){
      const int id = n + (e+offset)*p_Np;
      s_q[n] = q[id];
    }

    @barrier("local");

    for(int n=0;n<p_Np;++n;@inner(0)){

      const dfloat drdx = vgeo[p_Nvgeo*e+p_RXID];
      const dfloat drdy = vgeo[p_Nvgeo*e+p_RYID];
      const dfloat dsdx = vgeo[p_Nvgeo*e+p_SXID];
      const dfloat dsdy = vgeo[p_Nvgeo*e+p_SYID];

      dfloat qr = 0.f, qs = 0.f;
      #pragma unroll p_Np
      for(int i=0;i<p_Np;++i){
        qr += Dmatrices[n + i*p_Np + 0*p_Np*p_Np]*s_q[i];
        qs += Dmatrices[n + i*p_Np + 1*p_Np*p_Np]*s_q[i];
      }

      dfloat4 gradqn;
      gradqn.x = drdx*qr + dsdx*qs;
      gradqn.y = drdy*qr + dsdy*qs;
      gradqn.w = s_q[n];
      
      const dlong id = (e+offset)*p_Np+n; 
      gradq[id] = gradqn;
    }
  }
}


  // // Optimized sizes for kernel 3
#if p_N==1
 #define p_Nblock 8
#endif

#if p_N==2
 #define p_Nblock 8
#endif

#if p_N==3
 #define p_Nblock 6
#endif

 #if p_N==4
  #define p_Nblock 6
#endif

#if p_N==5
 #define p_Nblock 6
#endif

#if p_N==6
 #define p_Nblock 8
#endif

#if p_N==7
  #define p_Nblock 8
#endif

#if p_N==8
 #define p_Nblock 7
#endif

#if p_N==9
  #define p_Nblock 9
#endif

#if p_N==10
 #define p_Nblock 10
#endif


@kernel void ellipticPartialGradientTri2D_v3(          const dlong Nelements,
                                                       const dlong offset,
                                             @restrict const dfloat *vgeo,
                                             @restrict const dfloat *Dmatrices, 
                                             @restrict const dfloat *q,
                                             @restrict       dfloat4 *gradq){
  
  for(dlong eo=0;eo<Nelements;eo+=p_Nblock;@outer(0)){

    @shared dfloat s_q[p_Nblock][p_Np];

    for(int es=0; es<p_Nblock; ++es; @inner(1)){
      const dlong e = es+eo+offset; 
      if(e<Nelements){
        for(int n=0;n<p_Np; ++n; @inner(0)){
          const dlong id = n + e*p_Np;
          s_q[es][n] = q[id];
        }
     }
    }

    @barrier("local");

    for(int es=0;es<p_Nblock; ++es; @inner(1)){
      const dlong e = es + eo+ offset; 
      if(e<Nelements){
        for(int n=0;n<p_Np;++n;@inner(0)){

          const dfloat drdx = vgeo[p_Nvgeo*e+p_RXID];
          const dfloat drdy = vgeo[p_Nvgeo*e+p_RYID];
          const dfloat dsdx = vgeo[p_Nvgeo*e+p_SXID];
          const dfloat dsdy = vgeo[p_Nvgeo*e+p_SYID];

          dfloat qr = 0.f, qs = 0.f;

          #pragma unroll p_Np
          for(int i=0;i<p_Np;++i){
            qr += Dmatrices[n + i*p_Np + 0*p_Np*p_Np]*s_q[es][i];
            qs += Dmatrices[n + i*p_Np + 1*p_Np*p_Np]*s_q[es][i];
          }

          dfloat4 gradqn;
          gradqn.x = drdx*qr + dsdx*qs;
          gradqn.y = drdy*qr + dsdy*qs;
          gradqn.w = s_q[es][n];

          const dlong id = e*p_Np+n; 
          gradq[id] = gradqn;
        }
      }
    }

  }
}


  // // Optimized sizes for kernel 4-5
#if p_N==1
 #define p_NbV 10
 #define p_Nmt 1
 #endif

#if p_N==2
 #define p_NbV 4
 #define p_Nmt 2
#endif

#if p_N==3
 #define p_NbV 6
 #define p_Nmt 1
#endif

 #if p_N==4
  #define p_NbV 2
  #define p_Nmt 2
#endif

 #if p_N==5
 #define p_NbV 2
 #define p_Nmt 5
 #endif

#if p_N==6
 #define p_NbV 3
 #define p_Nmt 7
 #endif

#if p_N==7
  #define p_NbV 2
  #define p_Nmt 7
 #endif

#if p_N==8
 #define p_NbV 5
 #define p_Nmt 7
#endif

#if p_N==9
  #define p_NbV 5
  #define p_Nmt 7
 #endif

#if p_N==10
 #define p_NbV 4
 #define p_Nmt 6
#endif


@kernel void ellipticPartialGradientTri2D_v4(          const dlong Nelements,
                                                       const dlong offset,
                                             @restrict const dfloat *vgeo,
                                             @restrict const dfloat *Dmatrices, 
                                             @restrict const dfloat *q,
                                             @restrict       dfloat4 *gradq){
  
  for(dlong eo=0;eo<Nelements;eo+=(p_NbV*p_Nmt);@outer(0)){

    @shared dfloat s_q[p_Nmt][p_NbV][p_Np];

    for(int es=0; es<p_NbV;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        #pragma unroll p_Nmt 
        for(int em=0;em<p_Nmt;++em){    
          const dlong e = eo+es*p_Nmt + em+offset; 
            if(e<Nelements){
              const dlong id = n + e*p_Np;
              s_q[em][es][n] = q[id];
            }
          }  
        }
      }

    @barrier("local");

    for(int es=0;es<p_NbV; ++es; @inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        dfloat qr[p_Nmt], qs[p_Nmt];

        // hold geometric factors on register
        dfloat drdx[p_Nmt], dsdx[p_Nmt];
        dfloat drdy[p_Nmt], dsdy[p_Nmt];
        
        #pragma unroll p_Nmt 
        for(int em=0;em<p_Nmt;++em){ 
          const dlong e = eo+es*p_Nmt + em+offset; 
          qr[em] = 0.f;
          qs[em] = 0.f;
          //
          drdx[em] = vgeo[p_Nvgeo*e+p_RXID];
          drdy[em] = vgeo[p_Nvgeo*e+p_RYID];
          dsdx[em] = vgeo[p_Nvgeo*e+p_SXID];
          dsdy[em] = vgeo[p_Nvgeo*e+p_SYID];
        }

        #pragma unroll p_Np
        for(int i=0;i<p_Np;++i){
          dfloat drt = Dmatrices[n + i*p_Np+0*p_Np*p_Np];
          dfloat dst = Dmatrices[n + i*p_Np+1*p_Np*p_Np];

          #pragma unroll p_Nmt 
          for(int em=0;em<p_Nmt;++em){ 
          qr[em] += drt*s_q[em][es][i];
          qs[em] += dst*s_q[em][es][i];
         }
        }


        dfloat4 gradqn;

        #pragma unroll p_Nmt 
        for(int em=0;em<p_Nmt;++em){ 
         const dlong e  = eo+es*p_Nmt + em+offset; 
         if(e<Nelements){ 
           const dlong id = e*p_Np+n; 
           gradqn.x = drdx[em]*qr[em] + dsdx[em]*qs[em];
           gradqn.y = drdy[em]*qr[em] + dsdy[em]*qs[em];
           gradqn.w = s_q[em][es][n];

           gradq[id] = gradqn;
          }
        }
      }
    }
  }
}

  // // Optimized sizes for kernel 4-5
#if p_N==1
 #define p_NbV2 8
 #define p_Nmt2 1
 #endif

#if p_N==2
 #define p_NbV2 8
 #define p_Nmt2 1
#endif

#if p_N==3
 #define p_NbV2 2
 #define p_Nmt2 3
#endif

 #if p_N==4
  #define p_NbV2 2
  #define p_Nmt2 3
#endif

 #if p_N==5
 #define p_NbV2 1
 #define p_Nmt2 3
 #endif

#if p_N==6
 #define p_NbV2 4
 #define p_Nmt2 7
 #endif

#if p_N==7
  #define p_NbV2 2
  #define p_Nmt2 7
 #endif

#if p_N==8
 #define p_NbV2 6
 #define p_Nmt2 7
#endif

#if p_N==9
  #define p_NbV2 6
  #define p_Nmt2 7
 #endif

#if p_N==10
 #define p_NbV2 4
 #define p_Nmt2 6
#endif


// same with v4 but use shared memory for geometric factors instead of 
// register memory
@kernel void ellipticPartialGradientTri2D_v5(          const dlong Nelements,
                                                       const dlong offset,
                                             @restrict const dfloat *vgeo,
                                             @restrict const dfloat *Dmatrices, 
                                             @restrict const dfloat *q,
                                             @restrict       dfloat4 *gradq){
  
  for(dlong eo=0;eo<Nelements;eo+=(p_NbV2*p_Nmt2);@outer(0)){

    @shared dfloat s_q[p_Nmt2][p_NbV2][p_Np];
    @shared dfloat s_vgeo[p_Nmt2][p_NbV2][p_Nvgeo];

    for(int es=0; es<p_NbV2;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        #pragma unroll p_Nmt2 
        for(int em=0;em<p_Nmt2;++em){    
          const dlong e = eo+es*p_Nmt2 + em+offset; 
            if(e<Nelements){
              const dlong id = n + e*p_Np;
              s_q[em][es][n] = q[id];
            }
          } 

        int m = n;
        while(m<p_Nvgeo*p_Nmt2*p_NbV2){
          s_vgeo[0][0][m] = vgeo[eo*p_Nvgeo + m];
          m+=p_Np*p_NbV2;
        }
      }
    }

    @barrier("local");

    for(int es=0;es<p_NbV2; ++es; @inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        dfloat qr[p_Nmt2], qs[p_Nmt2];  
        
        #pragma unroll p_Nmt2 
        for(int em=0;em<p_Nmt2;++em){ 
          const int e = eo+es*p_Nmt2 + em+offset; 
          qr[em] = 0.f;
          qs[em] = 0.f;
        }

        #pragma unroll p_Np
        for(int i=0;i<p_Np;++i){
          dfloat drt = Dmatrices[n + i*p_Np + 0*p_Np*p_Np];
          dfloat dst = Dmatrices[n + i*p_Np + 1*p_Np*p_Np];

          #pragma unroll p_Nmt2 
          for(int em=0;em<p_Nmt2;++em){ 
            qr[em] += drt*s_q[em][es][i];
            qs[em] += dst*s_q[em][es][i];
         }
        }

        dfloat4 gradqn;

        #pragma unroll p_Nmt2 
        for(int em=0;em<p_Nmt2;++em){ 
         const dlong e  = eo+es*p_Nmt2 + em+offset; 
         if(e<Nelements){ 
           const dlong id = e*p_Np+n; 
           gradqn.x = s_vgeo[em][es][p_RXID]*qr[em] + s_vgeo[em][es][p_SXID]*qs[em];
           gradqn.y = s_vgeo[em][es][p_RYID]*qr[em] + s_vgeo[em][es][p_SYID]*qs[em];
           gradqn.w = s_q[em][es][n];
           // Global update
           gradq[id] = gradqn;
          }
        }
      }
    }

  }
}








// use dfloat2 for Dr 
@kernel void ellipticPartialGradientTri2D_v6(          const dlong Nelements,
                                                       const dlong offset,
                                             @restrict const dfloat *vgeo,
                                             @restrict const dfloat2 *Dmatrices, 
                                             @restrict const dfloat *q,
                                             @restrict       dfloat4 *gradq){
  
  for(dlong eo=0;eo<Nelements;eo+=(p_NbV*p_Nmt);@outer(0)){

    @shared dfloat s_q[p_Nmt][p_NbV][p_Np];

    for(int es=0; es<p_NbV;++es;@inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        #pragma unroll p_Nmt 
        for(int em=0;em<p_Nmt;++em){    
          const dlong e = eo+es*p_Nmt + em+offset; 
            if(e<Nelements){
              const dlong id = n + e*p_Np;
              s_q[em][es][n] = q[id];
            }
          }  
        }
      }

    @barrier("local");

    for(int es=0;es<p_NbV; ++es; @inner(1)){
      for(int n=0;n<p_Np;++n;@inner(0)){
        dfloat qr[p_Nmt], qs[p_Nmt];

        // hold geometric factors on register
        dfloat drdx[p_Nmt], dsdx[p_Nmt];
        dfloat drdy[p_Nmt], dsdy[p_Nmt];
        
        #pragma unroll p_Nmt 
        for(int em=0;em<p_Nmt;++em){ 
          const dlong e = eo+es*p_Nmt + em+offset; 
          qr[em] = 0.f;
          qs[em] = 0.f;
          //
          drdx[em] = vgeo[p_Nvgeo*e+p_RXID];
          drdy[em] = vgeo[p_Nvgeo*e+p_RYID];
          dsdx[em] = vgeo[p_Nvgeo*e+p_SXID];
          dsdy[em] = vgeo[p_Nvgeo*e+p_SYID];
        }

        #pragma unroll p_Np
        for(int i=0;i<p_Np;++i){
          const dfloat2 drst = Dmatrices[n+i*p_Np];
          #pragma unroll p_Nmt 
          for(int em=0;em<p_Nmt;++em){ 
          qr[em] += drst.x*s_q[em][es][i];
          qs[em] += drst.y*s_q[em][es][i];
         }
        }


        dfloat4 gradqn;

        #pragma unroll p_Nmt 
        for(int em=0;em<p_Nmt;++em){ 
         const dlong e  = eo+es*p_Nmt + em+offset; 
         if(e<Nelements){ 
           const dlong id = e*p_Np+n; 
           gradqn.x = drdx[em]*qr[em] + dsdx[em]*qs[em];
           gradqn.y = drdy[em]*qr[em] + dsdy[em]*qs[em];
           gradqn.w = s_q[em][es][n];

           gradq[id] = gradqn;
          }
        }
      }
    }



  }
}



